

----QUIT----(28 June 2022 10:51:03) CuisUniversity-5324.image priorSource: 3389678!

----STARTUP---- (28 June 2022 10:51:03) as /Users/hernan/Documents/Cuis/5.0-64Bits/Cuis-University-Installer/CuisUniversity-5324.image!


----QUIT----(28 June 2022 10:51:03) CuisUniversity-5324.image priorSource: 7600809!

----STARTUP---- (30 June 2022 18:42:34) as C:\Users\Maxi\Desktop\Facultad\Inge1\cuisNuevo\windows64\CuisUniversity-5324.image!


----End fileIn of C:\Users\Maxi\Desktop\Facultad\Inge1\Parciales\2021-1c\2doParcial\ISW1-2021-1C-2doParcial.st----!

TestCase subclass: #RondaDeTrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTrucoTest category: 'ISW1-2021-1C-2doParcial' stamp: 'MY 6/30/2022 19:03:49'!
TestCase subclass: #RondaDeTrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTrucoTest methodsFor: 'no messages' stamp: 'MY 6/30/2022 19:04:24'!
test01! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:05:43'!
test01LaRondaComienzaConDosJugadores! !

!methodRemoval: RondaDeTrucoTest #test01 stamp: 'MY 6/30/2022 19:05:43'!
test01!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:05:55'!
test02LaRondaComienzaConTresCartas

	
	
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:06:24'!
test03LaRondaComienzaConCartasValidas! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:08:49'!
test01LaRondaComienzaConUnaManoYUnPie! !

!methodRemoval: RondaDeTrucoTest #test01LaRondaComienzaConDosJugadores stamp: 'MY 6/30/2022 19:08:49'!
test01LaRondaComienzaConDosJugadores!

false isNil!

(OrderedCollection new) isNil !

(OrderedCollection new) isNotNil   !

(OrderedCollection new isNil) or: (false isNil)!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'MY 6/30/2022 19:14:06'!
Object subclass: #RondaDeTruco
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:15:07' prior: 50569745!
test01LaRondaComienzaConUnaManoYUnPie

	| truco |
	truco := RondaDeTruco new.
	
	^ self assert: [(truco mano isNil) or: (truco pie isNil)] equals: false.! !

!testRun: #RondaDeTrucoTest #test01LaRondaComienzaConUnaManoYUnPie stamp: 'MY 6/30/2022 19:15:13'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:15:29' prior: 50569766!
test01LaRondaComienzaConUnaManoYUnPie

	| truco |
	truco := RondaDeTruco new.
	
	^ self assert: ((truco mano isNil) or: (truco pie isNil)) equals: false.! !

!testRun: #RondaDeTrucoTest #test01LaRondaComienzaConUnaManoYUnPie stamp: 'MY 6/30/2022 19:15:29'!
ERROR!

!testRun: #RondaDeTrucoTest #test01LaRondaComienzaConUnaManoYUnPie stamp: 'MY 6/30/2022 19:15:34'!
ERROR!
!RondaDeTruco methodsFor: 'accessing' stamp: 'MY 6/30/2022 19:15:37'!
mano
	self shouldBeImplemented.! !

!methodRemoval: RondaDeTruco #mano stamp: 'MY 6/30/2022 19:15:47'!
mano
	self shouldBeImplemented.!

!testRun: #RondaDeTrucoTest #test01LaRondaComienzaConUnaManoYUnPie stamp: 'MY 6/30/2022 19:15:50'!
ERROR!
!RondaDeTruco methodsFor: 'accessing' stamp: 'MY 6/30/2022 19:15:56'!
mano
	self shouldBeImplemented.! !

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'MY 6/30/2022 19:16:03'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'mano'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTruco methodsFor: 'accessing' stamp: 'MY 6/30/2022 19:16:01' prior: 50569802!
mano
	
	^ mano.! !

!testRun: #RondaDeTrucoTest #test01LaRondaComienzaConUnaManoYUnPie stamp: 'MY 6/30/2022 19:16:05'!
ERROR!
!RondaDeTruco methodsFor: 'accessing' stamp: 'MY 6/30/2022 19:16:11'!
pie
	self shouldBeImplemented.! !

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'MY 6/30/2022 19:16:17'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'mano pie'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTruco methodsFor: 'accessing' stamp: 'MY 6/30/2022 19:16:15' prior: 50569821!
pie
	^ pie! !

!testRun: #RondaDeTrucoTest #test01LaRondaComienzaConUnaManoYUnPie stamp: 'MY 6/30/2022 19:16:20'!
FAILURE!

!testRun: #RondaDeTrucoTest #test01LaRondaComienzaConUnaManoYUnPie stamp: 'MY 6/30/2022 19:16:23'!
FAILURE!

!testRun: #RondaDeTrucoTest #test01LaRondaComienzaConUnaManoYUnPie stamp: 'MY 6/30/2022 19:16:32'!
FAILURE!
!RondaDeTruco methodsFor: 'accessing' stamp: 'MY 6/30/2022 19:17:22' overrides: 16920235!
initialize

	mano := OrderedCollection new.
	pie := OrderedCollection new.! !

!testRun: #RondaDeTrucoTest #test01LaRondaComienzaConUnaManoYUnPie stamp: 'MY 6/30/2022 19:17:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test01LaRondaComienzaConUnaManoYUnPie stamp: 'MY 6/30/2022 19:17:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaConTresCartas stamp: 'MY 6/30/2022 19:17:31'!
PASSED!

!testRun: #RondaDeTrucoTest #test03LaRondaComienzaConCartasValidas stamp: 'MY 6/30/2022 19:17:31'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:19:03'!
test02LaRondaDebeComenzarConTresCartas

	
	
	! !

!methodRemoval: RondaDeTrucoTest #test02LaRondaComienzaConTresCartas stamp: 'MY 6/30/2022 19:19:03'!
test02LaRondaComienzaConTresCartas

	
	
	!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:21:05'!
test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas

	
	
	! !

!methodRemoval: RondaDeTrucoTest #test02LaRondaDebeComenzarConTresCartas stamp: 'MY 6/30/2022 19:21:05'!
test02LaRondaDebeComenzarConTresCartas

	
	
	!

----End fileIn of C:\Users\Maxi\Desktop\Facultad\Inge1\windows64\Portfolio-Solucion.st----!

----End fileIn of C:\Users\Maxi\Desktop\Facultad\Inge1\windows64\Portfolio-Solucion.st----!

----End fileIn of C:\Users\Maxi\Desktop\Facultad\Inge1\windows64\Portfolio-Solucion.st----!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:26:45' prior: 50569875!
test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas

	| truco cartasMano cartasPie |
	
	cartasPie := #().
	cartasMano := #().
	truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ]
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:31:27' prior: 50572766!
test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas

	| truco muchasCartas pocasCartas |
	
	muchasCartas := OrderedCollection new.
	muchasCartas add: (CartaDeTruco oroCon: 1).
	muchasCartas add: (CartaDeTruco oroCon: 2).
	muchasCartas add: (CartaDeTruco oroCon: 3).
	
	pocasCartas := OrderedCollection new.
	pocasCartas add: (CartaDeTruco bastoCon: 1).
	pocasCartas add: (CartaDeTruco bastoCon: 2).
	
	
	self should: [ truco := RondaDeTruco conMano: pocasCartas yPie: pocasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].
	
	self should: [ truco := RondaDeTruco conMano: muchasCartas yPie: muchasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ]
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:32:37' prior: 50572782!
test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas

	"| truco muchasCartas pocasCartas |"
	
	
	| muchasCartas |
	muchasCartas := OrderedCollection new.
	muchasCartas add: (CartaDeTruco oroCon: 1).
	muchasCartas add: (CartaDeTruco oroCon: 2).
	muchasCartas add: (CartaDeTruco oroCon: 3).
	
	"pocasCartas := OrderedCollection new.
	pocasCartas add: (CartaDeTruco bastoCon: 1).
	pocasCartas add: (CartaDeTruco bastoCon: 2).
	
	
	self should: [ truco := RondaDeTruco conMano: pocasCartas yPie: pocasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].
	
	self should: [ truco := RondaDeTruco conMano: muchasCartas yPie: muchasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ]"
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:32:45'!
muchasCartas

	| muchasCartas |
	muchasCartas := OrderedCollection new.
	muchasCartas add: (CartaDeTruco oroCon: 1).
	muchasCartas add: (CartaDeTruco oroCon: 2).
	muchasCartas add: (CartaDeTruco oroCon: 3)! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:32:45' prior: 50572811!
test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas

	"| truco muchasCartas pocasCartas |"
	
	
	self muchasCartas.
	
	"pocasCartas := OrderedCollection new.
	pocasCartas add: (CartaDeTruco bastoCon: 1).
	pocasCartas add: (CartaDeTruco bastoCon: 2).
	
	
	self should: [ truco := RondaDeTruco conMano: pocasCartas yPie: pocasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].
	
	self should: [ truco := RondaDeTruco conMano: muchasCartas yPie: muchasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ]"
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:33:15' prior: 50572851!
test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas

	"| truco muchasCartas pocasCartas |
	
	
	muchasCartas := self muchasCartas."
	
	| pocasCartas |
	
	pocasCartas := OrderedCollection new.
	pocasCartas add: (CartaDeTruco bastoCon: 1).
	pocasCartas add: (CartaDeTruco bastoCon: 2).
	"
	
	self should: [ truco := RondaDeTruco conMano: pocasCartas yPie: pocasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].
	
	self should: [ truco := RondaDeTruco conMano: muchasCartas yPie: muchasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ]"
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:33:22'!
pocasCartas

	| pocasCartas |
	
	pocasCartas := OrderedCollection new.
	pocasCartas add: (CartaDeTruco bastoCon: 1).
	pocasCartas add: (CartaDeTruco bastoCon: 2)! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:33:22' prior: 50572876!
test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas

	"| truco muchasCartas pocasCartas |
	
	
	muchasCartas := self muchasCartas."
	
	self pocasCartas.
	"
	
	self should: [ truco := RondaDeTruco conMano: pocasCartas yPie: pocasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].
	
	self should: [ truco := RondaDeTruco conMano: muchasCartas yPie: muchasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ]"
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:34:08' prior: 50572910!
test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas

	| truco muchasCartas pocasCartas |
	
	
	muchasCartas := self muchasCartas.
	pocasCartas := self pocasCartas.
	
	self should: [ truco := RondaDeTruco conMano: pocasCartas yPie: pocasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].
	
	self should: [ truco := RondaDeTruco conMano: muchasCartas yPie: muchasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ]
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:34:18' prior: 50572932!
test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas

	| truco muchasCartas pocasCartas |
	
	muchasCartas := self muchasCartas.
	pocasCartas := self pocasCartas.
	
	self should: [ truco := RondaDeTruco conMano: pocasCartas yPie: pocasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].
	
	self should: [ truco := RondaDeTruco conMano: muchasCartas yPie: muchasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ]
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:34:52'!
test04ElPieYLaManoDebenTenerCartasDistintasComienzaConCartasValidas! !

!testRun: #RondaDeTrucoTest #test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 19:36:54'!
ERROR!

!testRun: #RondaDeTrucoTest #test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 19:37:07'!
ERROR!
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 19:37:15'!
conMano: aRondaDeTrucoTest yPie: aRondaDeTrucoTest2 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeConMano: aRondaDeTrucoTest yPie: aRondaDeTrucoTest2 ! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 19:37:49' prior: 50572988!
conMano: cartasMano yPie: cartasPie 

	^self new initializeConMano: cartasMano yPie: cartasPie ! !

!testRun: #RondaDeTrucoTest #test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 19:38:01'!
ERROR!

!testRun: #RondaDeTrucoTest #test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 19:39:04'!
ERROR!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'MY 6/30/2022 19:39:15'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'mano pie cartasMano_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'MY 6/30/2022 19:39:15'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'mano pie cartasMano_CHANGE_ME cartasPie_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTruco methodsFor: 'initialization' stamp: 'MY 6/30/2022 19:39:15'!
initializeConMano: cartasMano yPie: cartasPie 
	self shouldBeImplemented.
	cartasMano_CHANGE_ME := cartasMano.
	cartasPie_CHANGE_ME := cartasPie.! !
!RondaDeTruco methodsFor: 'initialization' stamp: 'MY 6/30/2022 19:39:30' prior: 50573030!
initializeConMano: cartasMano yPie: cartasPie
 
	mano := cartasMano.
	pie := cartasPie.! !

!testRun: #RondaDeTrucoTest #test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 19:39:33'!
FAILURE!

!testRun: #RondaDeTrucoTest #test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 19:39:33'!
FAILURE!

!testRun: #RondaDeTrucoTest #test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 19:39:57'!
FAILURE!

!methodRemoval: RondaDeTrucoTest #test01LaRondaComienzaConUnaManoYUnPie stamp: 'MY 6/30/2022 19:40:19'!
test01LaRondaComienzaConUnaManoYUnPie

	| truco |
	truco := RondaDeTruco new.
	
	^ self assert: ((truco mano isNil) or: (truco pie isNil)) equals: false.!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:40:24'!
test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas

	| truco muchasCartas pocasCartas |
	
	muchasCartas := self muchasCartas.
	pocasCartas := self pocasCartas.
	
	self should: [ truco := RondaDeTruco conMano: pocasCartas yPie: pocasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].
	
	self should: [ truco := RondaDeTruco conMano: muchasCartas yPie: muchasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ]
	! !

!methodRemoval: RondaDeTrucoTest #test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 19:40:24'!
test02LaRondaDebeLanzarErrorSiNoComenzarConTresCartas

	| truco muchasCartas pocasCartas |
	
	muchasCartas := self muchasCartas.
	pocasCartas := self pocasCartas.
	
	self should: [ truco := RondaDeTruco conMano: pocasCartas yPie: pocasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].
	
	self should: [ truco := RondaDeTruco conMano: muchasCartas yPie: muchasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ]
	!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:40:29'!
test02LaRondaComienzaConCartasValidas! !

!methodRemoval: RondaDeTrucoTest #test03LaRondaComienzaConCartasValidas stamp: 'MY 6/30/2022 19:40:29'!
test03LaRondaComienzaConCartasValidas!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:40:33'!
test03ElPieYLaManoDebenTenerCartasDistintasComienzaConCartasValidas! !

!methodRemoval: RondaDeTrucoTest #test04ElPieYLaManoDebenTenerCartasDistintasComienzaConCartasValidas stamp: 'MY 6/30/2022 19:40:33'!
test04ElPieYLaManoDebenTenerCartasDistintasComienzaConCartasValidas!

!methodRemoval: RondaDeTruco #mano stamp: 'MY 6/30/2022 19:40:36'!
mano
	
	^ mano.!

!methodRemoval: RondaDeTruco #pie stamp: 'MY 6/30/2022 19:40:37'!
pie
	^ pie!

!methodRemoval: RondaDeTruco #initialize stamp: 'MY 6/30/2022 19:40:40'!
initialize

	mano := OrderedCollection new.
	pie := OrderedCollection new.!
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 19:41:20' prior: 50572999!
conMano: cartasMano yPie: cartasPie 

	self validarCartas.
	^self new initializeConMano: cartasMano yPie: cartasPie ! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 19:41:45' prior: 50573138!
conMano: cartasMano yPie: cartasPie 

	self validarCartas: cartasMano y: cartasPie.
	^self new initializeConMano: cartasMano yPie: cartasPie ! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 19:43:21'!
validarCartas: cartasMano y: cartasPie 

	((cartasMano size ~= 3) and: (cartasMano size ~= 3)) ifTrue: [^ self cartasInvalidas].
	! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 19:44:19' prior: 50573153!
validarCartas: cartasMano y: cartasPie 

	((cartasMano size ~= 3) and: (cartasMano size ~= 3)) ifTrue: [^ self error: self cartasInvalidas].
	! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 19:44:42'!
cartasInvalidas

	^ 'Ambos jugadores deben tener 3 cartas'
	! !

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 19:44:53'!
PASSED!

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 19:44:53'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaConCartasValidas stamp: 'MY 6/30/2022 19:44:53'!
PASSED!

!testRun: #RondaDeTrucoTest #test03ElPieYLaManoDebenTenerCartasDistintasComienzaConCartasValidas stamp: 'MY 6/30/2022 19:44:53'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:46:21'!
manoDeCartasValidas1

	| pocasCartas |
	
	pocasCartas := OrderedCollection new.
	pocasCartas add: (CartaDeTruco bastoCon: 1).
	pocasCartas add: (CartaDeTruco bastoCon: 2).
	pocasCartas add: (CartaDeTruco bastoCon: 3)! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:46:39' prior: 50573190!
manoDeCartasValidas1

	| mano |
	
	mano := OrderedCollection new.
	mano add: (CartaDeTruco bastoCon: 1).
	mano add: (CartaDeTruco bastoCon: 2).
	mano add: (CartaDeTruco bastoCon: 3).
	
	^mano.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:46:42' prior: 50573200!
manoDeCartasValidas1

	| mano |
	
	mano := OrderedCollection new.
	mano add: (CartaDeTruco bastoCon: 1).
	mano add: (CartaDeTruco bastoCon: 2).
	mano add: (CartaDeTruco bastoCon: 3).
	
	^ mano.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:46:57' prior: 50572901!
pocasCartas

	| pocasCartas |
	
	pocasCartas := OrderedCollection new.
	pocasCartas add: (CartaDeTruco bastoCon: 1).
	pocasCartas add: (CartaDeTruco bastoCon: 2).
	
	^ pocasCartas.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:47:10' prior: 50572841!
muchasCartas

	| muchasCartas |
	muchasCartas := OrderedCollection new.
	muchasCartas add: (CartaDeTruco oroCon: 1).
	muchasCartas add: (CartaDeTruco oroCon: 2).
	muchasCartas add: (CartaDeTruco oroCon: 3).
	
	^ muchasCartas.! !

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 19:47:13'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:47:25' prior: 50573064!
test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas

	| truco muchasCartas pocasCartas |
	
	muchasCartas := self muchasCartas.
	pocasCartas := self pocasCartas.
	
	self should: [ RondaDeTruco conMano: pocasCartas yPie: pocasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].
	
	self should: [ RondaDeTruco conMano: muchasCartas yPie: muchasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ]
	! !

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 19:47:29'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:47:35' prior: 50573244!
test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas

	| truco muchasCartas pocasCartas |
	
	muchasCartas := self muchasCartas.
	pocasCartas := self pocasCartas.
	
	self should: [ truco := RondaDeTruco conMano: pocasCartas yPie: pocasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].
	
	self should: [ truco := RondaDeTruco conMano: muchasCartas yPie: muchasCartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ]
	! !

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 19:47:45'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:49:24' prior: 50573229!
muchasCartas

	| muchasCartas |
	muchasCartas := OrderedCollection new.
	muchasCartas add: (CartaDeTruco oroCon: 1).
	muchasCartas add: (CartaDeTruco oroCon: 2).
	muchasCartas add: (CartaDeTruco oroCon: 3).
	muchasCartas add: (CartaDeTruco oroCon: 4).
	
	^ muchasCartas.! !

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 19:49:27'!
PASSED!

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 19:49:27'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaConCartasValidas stamp: 'MY 6/30/2022 19:49:27'!
PASSED!

!testRun: #RondaDeTrucoTest #test03ElPieYLaManoDebenTenerCartasDistintasComienzaConCartasValidas stamp: 'MY 6/30/2022 19:49:27'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:51:30' prior: 50573107!
test02LaRondaComienzaConCartasValidas

	| truco cartas cartasRepetidas |
	
	cartas := self manoDeCartasValidas1 .
	cartasRepetidas := self cartasRepetidas.
	
	self should: [ truco := RondaDeTruco conMano: cartas yPie: cartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].
	
	self should: [ truco := RondaDeTruco conMano: cartasRepetidas yPie: cartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ]
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:51:43'!
cartasRepetidas

	| mano |
	
	mano := OrderedCollection new.
	mano add: (CartaDeTruco bastoCon: 1).
	mano add: (CartaDeTruco bastoCon: 1).
	mano add: (CartaDeTruco bastoCon: 3).
	
	^ mano.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 19:52:50'!
test02LaRondaComienzaSinCartasRepetidas

	| truco cartas cartasRepetidas |
	
	cartas := self manoDeCartasValidas1 .
	cartasRepetidas := self cartasRepetidas.
	
	self should: [ truco := RondaDeTruco conMano: cartas yPie: cartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].
	
	self should: [ truco := RondaDeTruco conMano: cartasRepetidas yPie: cartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ]
	! !

!methodRemoval: RondaDeTrucoTest #test02LaRondaComienzaConCartasValidas stamp: 'MY 6/30/2022 19:52:50'!
test02LaRondaComienzaConCartasValidas

	| truco cartas cartasRepetidas |
	
	cartas := self manoDeCartasValidas1 .
	cartasRepetidas := self cartasRepetidas.
	
	self should: [ truco := RondaDeTruco conMano: cartas yPie: cartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].
	
	self should: [ truco := RondaDeTruco conMano: cartasRepetidas yPie: cartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ]
	!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 6/30/2022 19:52:58'!
FAILURE!
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 19:53:45' prior: 50573145!
conMano: cartasMano yPie: cartasPie 

	| mano pie |
	
	mano := cartasMano asSet.
	
	self validarCartas: cartasMano y: cartasPie.
	^self new initializeConMano: cartasMano yPie: cartasPie ! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 19:54:09' prior: 50573398!
conMano: cartasMano yPie: cartasPie 

	| mano pie |
	
	mano := cartasMano asSet.
	pie := cartasPie asSet.
	
	self validarCartas: mano y: pie.
	^self new initializeConMano: mano yPie: pie ! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 19:54:19' prior: 50573169!
cartasInvalidas

	^ 'Ambos jugadores deben tener 3 cartas no repetidas'
	! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 19:55:02' prior: 50573161!
validarCartas: cartasMano y: cartasPie 

	((cartasMano size ~= 3) and: (cartasPie size ~= 3)) ifTrue: [^ self error: self cartasInvalidas].
	! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 19:56:47'!
tieneTresCartas: cartasMano y: cartasPie

	^ ((cartasMano size ~= 3) and: (cartasPie size ~= 3))	! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 19:56:52' prior: 50573432!
tieneTresCartas: cartasMano y: cartasPie

	^ (cartasMano size ~= 3) and: (cartasPie size ~= 3)	! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 19:57:33' prior: 50573424!
validarCartas: cartasMano y: cartasPie 

	((self tieneTresCartas: cartasMano y: cartasPie) and: (true)) ifTrue: [^ self error: self cartasInvalidas].
	! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 19:58:37' prior: 50573446!
validarCartas: cartasMano y: cartasPie 

	((self tieneTresCartas: cartasMano y: cartasPie) and: (true)) ifTrue: [^ self error: self cartasInvalidas].
	! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 20:00:28' prior: 50573454!
validarCartas: cartasMano y: cartasPie 

	((self tieneTresCartas: cartasMano y: cartasPie) and: (self sonDistintas: cartasMano y: cartasPie)) ifTrue: [^ self error: self cartasInvalidas].
	! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 20:00:38'!
sonDistintas: cartasMano y: cartasPie 

	^ (cartasMano union: cartasPie) size = 6! !

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 6/30/2022 20:00:43'!
FAILURE!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 6/30/2022 20:00:47'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:00:53' prior: 50573353!
test02LaRondaComienzaSinCartasRepetidas

	| truco cartas cartasRepetidas |
	
	cartas := self manoDeCartasValidas1.
	cartasRepetidas := self cartasRepetidas.
	
	self should: [ truco := RondaDeTruco conMano: cartas yPie: cartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].
	
	self should: [ truco := RondaDeTruco conMano: cartasRepetidas yPie: cartas ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ]
	! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 20:02:24' prior: 50573471!
sonDistintas: cartasMano y: cartasPie 

	^ (cartasMano union: cartasPie) size ~= 6! !
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 20:02:40'!
NoTieneTresCartas: cartasMano o: cartasPie

	^ (cartasMano size ~= 3) and: (cartasPie size ~= 3)	! !
!RondaDeTruco class methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:02:40' prior: 50573462!
validarCartas: cartasMano y: cartasPie 

	((self NoTieneTresCartas: cartasMano o: cartasPie) and: (self sonDistintas: cartasMano y: cartasPie)) ifTrue: [^ self error: self cartasInvalidas].
	! !

!methodRemoval: RondaDeTruco class #tieneTresCartas:y: stamp: 'MY 6/30/2022 20:02:40'!
tieneTresCartas: cartasMano y: cartasPie

	^ (cartasMano size ~= 3) and: (cartasPie size ~= 3)	!
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 20:02:59'!
noTieneTresCartas: cartasMano o: cartasPie

	^ (cartasMano size ~= 3) and: (cartasPie size ~= 3)	! !
!RondaDeTruco class methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:03:00' prior: 50573518!
validarCartas: cartasMano y: cartasPie 

	((self noTieneTresCartas: cartasMano o: cartasPie) and: (self sonDistintas: cartasMano y: cartasPie)) ifTrue: [^ self error: self cartasInvalidas].
	! !

!methodRemoval: RondaDeTruco class #NoTieneTresCartas:o: stamp: 'MY 6/30/2022 20:03:00'!
NoTieneTresCartas: cartasMano o: cartasPie

	^ (cartasMano size ~= 3) and: (cartasPie size ~= 3)	!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 6/30/2022 20:03:05'!
FAILURE!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 6/30/2022 20:03:10'!
FAILURE!
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 20:08:07'!
hayRepetidasEn: cartasMano y: cartasPie 

	^ (cartasMano union: cartasPie) size ~= 6! !
!RondaDeTruco class methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:08:07' prior: 50573540!
validarCartas: cartasMano y: cartasPie 

	((self noTieneTresCartas: cartasMano o: cartasPie) and: (self hayRepetidasEn: cartasMano y: cartasPie)) ifTrue: [^ self error: self cartasInvalidas].
	! !

!methodRemoval: RondaDeTruco class #sonDistintas:y: stamp: 'MY 6/30/2022 20:08:07'!
sonDistintas: cartasMano y: cartasPie 

	^ (cartasMano union: cartasPie) size ~= 6!
!RondaDeTruco class methodsFor: 'instance creation' stamp: 'MY 6/30/2022 20:08:25' prior: 50573568!
validarCartas: cartasMano y: cartasPie 

	((self noTieneTresCartas: cartasMano o: cartasPie) or: (self hayRepetidasEn: cartasMano y: cartasPie)) ifTrue: [^ self error: self cartasInvalidas].
	! !

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 6/30/2022 20:08:33'!
PASSED!

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 20:08:33'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 6/30/2022 20:08:33'!
PASSED!

!testRun: #RondaDeTrucoTest #test03ElPieYLaManoDebenTenerCartasDistintasComienzaConCartasValidas stamp: 'MY 6/30/2022 20:08:33'!
PASSED!

!methodRemoval: RondaDeTrucoTest #test03ElPieYLaManoDebenTenerCartasDistintasComienzaConCartasValidas stamp: 'MY 6/30/2022 20:11:36'!
test03ElPieYLaManoDebenTenerCartasDistintasComienzaConCartasValidas!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:12:42'!
test03NoSePuedeJugarCartaQueNoEsteEnMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:12:41' prior: 50573614!
test03NoSePuedeJugarCartaQueNoEsteEnMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartasInvalidas ].! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:13:12'!
manoDeCartasValidas2

	| mano |
	
	mano := OrderedCollection new.
	mano add: (CartaDeTruco espadaCon: 1).
	mano add: (CartaDeTruco espadaCon: 2).
	mano add: (CartaDeTruco espadaCon: 3).
	
	^ mano.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:15:18' prior: 50573629!
test03NoSePuedeJugarCartaQueNoEsteEnMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco manoJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano ].! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:15:42' prior: 50573654!
test03NoSePuedeJugarCartaQueNoEsteEnMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco manoJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano ].
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco pieJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano ].! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:16:09'!
test04JugarCartaDebeDescontarCartaDeMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco manoJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano ].
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco pieJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano ].! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:16:15'!
xtest04JugarCartaDebeDescontarCartaDeMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco manoJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano ].
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco pieJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano ].! !

!methodRemoval: RondaDeTrucoTest #test04JugarCartaDebeDescontarCartaDeMano stamp: 'MY 6/30/2022 20:16:15'!
test04JugarCartaDebeDescontarCartaDeMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco manoJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano ].
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco pieJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano ].!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:17:07' prior: 50573671!
test03NoSePuedeJugarCartaQueNoEsteEnMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco manoJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano 
			truco cartasMano size = 3].
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco pieJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano ].! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:17:15' prior: 50573768!
test03NoSePuedeJugarCartaQueNoEsteEnMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco manoJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano.
			truco cartasMano size = 3].
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco pieJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano ].! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:17:27' prior: 50573793!
test03NoSePuedeJugarCartaQueNoEsteEnMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco manoJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano.
			truco cartasMano size = 3].
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco pieJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano 
			truco cartasPie size = 3].! !

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 6/30/2022 20:17:35'!
ERROR!
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 6/30/2022 20:18:07'!
manoJuega: aCartaDeTruco 
	self shouldBeImplemented.! !
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 6/30/2022 20:25:43' prior: 50573847!
manoJuega: aCartaDeTruco 
	
	(mano includes: aCartaDeTruco) ifFalse: [^self error: RondaDeTruco cartaNoIncluidaEnMano].! !

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 6/30/2022 20:25:48'!
ERROR!
!RondaDeTruco class methodsFor: 'error-message' stamp: 'MY 6/30/2022 20:26:17'!
cartaNoIncluidaEnMano
	self shouldBeImplemented.! !
!RondaDeTruco class methodsFor: 'error-message' stamp: 'MY 6/30/2022 20:26:27' prior: 50573862!
cartaNoIncluidaEnMano
	
	^ 'La carta no está incluida en la mano'! !

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 6/30/2022 20:26:29'!
ERROR!
!RondaDeTruco methodsFor: 'accessing' stamp: 'MY 6/30/2022 20:26:36'!
cartasMano
	self shouldBeImplemented.! !
!RondaDeTruco methodsFor: 'accessing' stamp: 'MY 6/30/2022 20:26:40' prior: 50573875!
cartasMano
	
	^mano.! !

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 6/30/2022 20:26:43'!
ERROR!
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 6/30/2022 20:26:57'!
pieJuega: aCartaDeTruco 
	
	(pie includes: aCartaDeTruco) ifFalse: [^self error: RondaDeTruco cartaNoIncluidaEnMano].! !
!RondaDeTruco methodsFor: 'accessing' stamp: 'MY 6/30/2022 20:27:21'!
cartasPie
	
	^ pie.! !
!RondaDeTruco methodsFor: 'accessing' stamp: 'MY 6/30/2022 20:27:24' prior: 50573879!
cartasMano
	
	^ mano.! !

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 6/30/2022 20:27:29'!
ERROR!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:28:05' prior: 50573818!
test03NoSePuedeJugarCartaQueNoEsteEnMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco manoJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano.
			truco cartasMano size = 3].
	
	self should: [ truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
		truco pieJuega: (CartaDeTruco oroCon: 4)]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = RondaDeTruco cartaNoIncluidaEnMano.
			truco cartasPie size = 3].! !

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 6/30/2022 20:28:07'!
PASSED!

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 20:28:07'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 6/30/2022 20:28:07'!
PASSED!

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 6/30/2022 20:28:07'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:28:48' prior: 50573719!
xtest04JugarCartaDebeDescontarCartaDeMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco oroCon: 4)
	
	! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:30:16' prior: 50573944!
xtest04JugarCartaDebeDescontarCartaDeMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	
	self assert: (truco cartasMano size) equals: 2.
	! !

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 20:30:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 6/30/2022 20:30:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 6/30/2022 20:30:17'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:30:19'!
test04JugarCartaDebeDescontarCartaDeMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	
	self assert: (truco cartasMano size) equals: 2.
	! !

!testRun: #RondaDeTrucoTest #test04JugarCartaDebeDescontarCartaDeMano stamp: 'MY 6/30/2022 20:30:20'!
FAILURE!

!testRun: #RondaDeTrucoTest #test04JugarCartaDebeDescontarCartaDeMano stamp: 'MY 6/30/2022 20:30:23'!
FAILURE!
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 6/30/2022 20:31:21' prior: 50573852!
manoJuega: aCartaDeTruco 
	
	(mano includes: aCartaDeTruco) ifFalse: [^self error: RondaDeTruco cartaNoIncluidaEnMano].
	
	mano remove: aCartaDeTruco.! !

!methodRemoval: RondaDeTrucoTest #xtest04JugarCartaDebeDescontarCartaDeMano stamp: 'MY 6/30/2022 20:31:25'!
xtest04JugarCartaDebeDescontarCartaDeMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	
	self assert: (truco cartasMano size) equals: 2.
	!

!testRun: #RondaDeTrucoTest #test04JugarCartaDebeDescontarCartaDeMano stamp: 'MY 6/30/2022 20:31:26'!
PASSED!

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 20:31:27'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 6/30/2022 20:31:27'!
PASSED!

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 6/30/2022 20:31:27'!
PASSED!

!testRun: #RondaDeTrucoTest #test04JugarCartaDebeDescontarCartaDeMano stamp: 'MY 6/30/2022 20:31:27'!
PASSED!
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 6/30/2022 20:31:38' prior: 50574000!
manoJuega: aCartaDeTruco 
	
	self jugar: aCartaDeTruco con: mano.! !
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 6/30/2022 20:32:01'!
jugar: aCartaDeTruco con: aJugador
	
	(aJugador includes: aCartaDeTruco) ifFalse: [^self error: RondaDeTruco cartaNoIncluidaEnMano].
	
	aJugador remove: aCartaDeTruco.! !

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 20:32:04'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 6/30/2022 20:32:04'!
PASSED!

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 6/30/2022 20:32:04'!
PASSED!

!testRun: #RondaDeTrucoTest #test04JugarCartaDebeDescontarCartaDeMano stamp: 'MY 6/30/2022 20:32:04'!
PASSED!
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 6/30/2022 20:32:20' prior: 50573886!
pieJuega: aCartaDeTruco 
	
	self jugar: aCartaDeTruco con: pie.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:32:42' prior: 50573980!
test04JugarCartaDebeDescontarCartaDeMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	
	self assert: (truco cartasMano size) equals: 2.
	
	truco pieJuega: (CartaDeTruco espadaCon: 3).
	
	self assert: (truco cartasPie size) equals: 2.
	! !

!testRun: #RondaDeTrucoTest #test04JugarCartaDebeDescontarCartaDeMano stamp: 'MY 6/30/2022 20:32:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 20:32:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 6/30/2022 20:32:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 6/30/2022 20:32:43'!
PASSED!

!testRun: #RondaDeTrucoTest #test04JugarCartaDebeDescontarCartaDeMano stamp: 'MY 6/30/2022 20:32:43'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:32:50' prior: 50574073!
test04JugarCartaDebeDescontarCartaDeMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
	
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	self assert: (truco cartasMano size) equals: 2.
	
	truco pieJuega: (CartaDeTruco espadaCon: 3).
	self assert: (truco cartasPie size) equals: 2.
	! !

!testRun: #RondaDeTrucoTest #test04JugarCartaDebeDescontarCartaDeMano stamp: 'MY 6/30/2022 20:32:52'!
PASSED!

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 20:32:52'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 6/30/2022 20:32:52'!
PASSED!

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 6/30/2022 20:32:52'!
PASSED!

!testRun: #RondaDeTrucoTest #test04JugarCartaDebeDescontarCartaDeMano stamp: 'MY 6/30/2022 20:32:52'!
PASSED!

!classDefinition: #Enfrentamiento category: 'ISW1-2021-1C-2doParcial' stamp: 'MY 6/30/2022 20:36:13'!
Object subclass: #Enfrentamiento
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:36:06'!
test05ManoJuegaCartaCreaNuevoEnfrentamiento

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
	
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	self assert: (truco enfrentamientoActual isKindOf: Enfrentamiento)
	  ! !

!testRun: #RondaDeTrucoTest #test05ManoJuegaCartaCreaNuevoEnfrentamiento stamp: 'MY 6/30/2022 20:36:15'!
ERROR!
!RondaDeTruco methodsFor: 'accessing' stamp: 'MY 6/30/2022 20:36:24'!
enfrentamientoActual
	self shouldBeImplemented.! !

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'MY 6/30/2022 20:36:33'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'mano pie cartasMano_CHANGE_ME cartasPie_CHANGE_ME enfrentamiento'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTruco methodsFor: 'accessing' stamp: 'MY 6/30/2022 20:36:32' prior: 50574166!
enfrentamientoActual
	
	^ enfrentamiento! !

!testRun: #RondaDeTrucoTest #test05ManoJuegaCartaCreaNuevoEnfrentamiento stamp: 'MY 6/30/2022 20:36:36'!
FAILURE!
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 6/30/2022 20:37:54' prior: 50574039!
manoJuega: aCartaDeTruco 
	
	enfrentamiento := Enfrentamiento new.
	self jugar: aCartaDeTruco con: mano.! !

!testRun: #RondaDeTrucoTest #test05ManoJuegaCartaCreaNuevoEnfrentamiento stamp: 'MY 6/30/2022 20:37:58'!
PASSED!

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 20:37:58'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 6/30/2022 20:37:58'!
PASSED!

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 6/30/2022 20:37:58'!
PASSED!

!testRun: #RondaDeTrucoTest #test04JugarCartaDebeDescontarCartaDeMano stamp: 'MY 6/30/2022 20:37:58'!
PASSED!

!testRun: #RondaDeTrucoTest #test05ManoJuegaCartaCreaNuevoEnfrentamiento stamp: 'MY 6/30/2022 20:37:58'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:40:28'!
test05ManoJuegaCartaCreaPrimerEnfrentamiento

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
	
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	self assert: (truco enfrentamientoActual isKindOf: Enfrentamiento)
	  ! !

!methodRemoval: RondaDeTrucoTest #test05ManoJuegaCartaCreaNuevoEnfrentamiento stamp: 'MY 6/30/2022 20:40:28'!
test05ManoJuegaCartaCreaNuevoEnfrentamiento

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
	
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	self assert: (truco enfrentamientoActual isKindOf: Enfrentamiento)
	  !

!classDefinition: #PrimerEnfrentamiento category: 'ISW1-2021-1C-2doParcial' stamp: 'MY 6/30/2022 20:40:42'!
Enfrentamiento subclass: #PrimerEnfrentamiento
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:40:33' prior: 50574216!
test05ManoJuegaCartaCreaPrimerEnfrentamiento

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
	
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	self assert: (truco enfrentamientoActual isKindOf: PrimerEnfrentamiento)
	  ! !
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 6/30/2022 20:40:50' prior: 50574188!
manoJuega: aCartaDeTruco 
	
	enfrentamiento := PrimerEnfrentamiento new.
	self jugar: aCartaDeTruco con: mano.! !

!testRun: #RondaDeTrucoTest #test05ManoJuegaCartaCreaPrimerEnfrentamiento stamp: 'MY 6/30/2022 20:40:54'!
PASSED!

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 20:40:54'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 6/30/2022 20:40:54'!
PASSED!

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 6/30/2022 20:40:54'!
PASSED!

!testRun: #RondaDeTrucoTest #test04JugarCartaDebeDescontarCartaDeMano stamp: 'MY 6/30/2022 20:40:54'!
PASSED!

!testRun: #RondaDeTrucoTest #test05ManoJuegaCartaCreaPrimerEnfrentamiento stamp: 'MY 6/30/2022 20:40:54'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 6/30/2022 20:43:21' prior: 50574253!
test05ManoJuegaCartaCreaPrimerEnfrentamiento

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco conMano: cartasMano yPie: cartasPie.
	
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	self assert: (truco enfrentamientoActual isKindOf: PrimerEnfrentamiento)! !

!testRun: #RondaDeTrucoTest #test05ManoJuegaCartaCreaPrimerEnfrentamiento stamp: 'MY 6/30/2022 20:43:22'!
PASSED!

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 6/30/2022 20:43:22'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 6/30/2022 20:43:22'!
PASSED!

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 6/30/2022 20:43:22'!
PASSED!

!testRun: #RondaDeTrucoTest #test04JugarCartaDebeDescontarCartaDeMano stamp: 'MY 6/30/2022 20:43:22'!
PASSED!

!testRun: #RondaDeTrucoTest #test05ManoJuegaCartaCreaPrimerEnfrentamiento stamp: 'MY 6/30/2022 20:43:22'!
PASSED!

Object subclass: #RondaDeTruco
	instanceVariableNames: 'mano pie enfrentamiento'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classDefinition: #RondaDeTruco category: 'ISW1-2021-1C-2doParcial' stamp: 'MY 6/30/2022 20:44:22'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'mano pie enfrentamiento'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

----STARTUP---- (4 July 2022 01:46:23) as C:\Users\Maxi\Desktop\Facultad\Inge1\cuisNuevo\windows64\CuisUniversity-5324.image!


----End fileIn of C:\Users\Maxi\Desktop\Facultad\Inge1\cuisNuevo\windows64\ISW1-2021-1C-2doParcial.st----!

!testRun: #RondaDeTrucoTest #test07JugarPieEnPrimerEnfrentamientoDebeAumentarEnfrentamientosGanadosDeGanador stamp: 'MY 7/4/2022 01:58:28'!
ERROR!

!testRun: #RondaDeTrucoTest #test07JugarPieEnPrimerEnfrentamientoDebeAumentarEnfrentamientosGanadosDeGanador stamp: 'MY 7/4/2022 01:59:57'!
FAILURE!
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 7/4/2022 02:02:20' prior: 50570032!
pieJuega: aCartaDeTruco 
	
	self jugar: aCartaDeTruco con: pie.
	enfrentamiento respondeCon: aCartaDeTruco en: self.! !
!PrimerEnfrentamiento methodsFor: 'playing' stamp: 'MY 7/4/2022 02:02:45' prior: 50569942!
respondeCon: aCartaDeTruco en: aRondaDeTruco 
	
	(aCartaDeTruco mataA: cartaMano) ifTrue: [^ aRondaDeTruco pieGanoEnfrentamiento ]
	ifFalse: [^ aRondaDeTruco manoGanoEnfrentamiento ].! !

!testRun: #RondaDeTrucoTest #test07JugarPieEnPrimerEnfrentamientoDebeAumentarEnfrentamientosGanadosDeGanador stamp: 'MY 7/4/2022 02:02:50'!
PASSED!

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 7/4/2022 02:02:50'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 7/4/2022 02:02:50'!
PASSED!

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 7/4/2022 02:02:50'!
PASSED!

!testRun: #RondaDeTrucoTest #test04JugarCartaDebeDescontarCartaDeMano stamp: 'MY 7/4/2022 02:02:50'!
PASSED!

!testRun: #RondaDeTrucoTest #test05ManoJuegaCartaCreaPrimerEnfrentamientoConCartaJugada stamp: 'MY 7/4/2022 02:02:50'!
PASSED!

!testRun: #RondaDeTrucoTest #test06NoDebePoderJugarJugadorDosVecesEnUnTurno stamp: 'MY 7/4/2022 02:02:50'!
PASSED!

!testRun: #RondaDeTrucoTest #test07JugarPieEnPrimerEnfrentamientoDebeAumentarEnfrentamientosGanadosDeGanador stamp: 'MY 7/4/2022 02:02:50'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:04:47'!
test08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self assert: truco enfrentamientosGanadosMano equals: 1.
	self assert: truco enfrentamientosGanadosPie equals: 0.! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:05:36' prior: 50570158!
test08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco bastoCon: 2).
	
	self should: []
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco yaJugoEsteTurno ]
		! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:06:06' prior: 50570176!
test08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: []
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco yaJugoEsteTurno ]
		! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:07:44' prior: 50570194!
test08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: []
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco yaJugoEsteTurno.
		"self assert: truco enfrentamientosGanadosMano equals: 1.
		self assert: truco enfrentamientosGanadosPie equals: 0." ]
		! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:08:18' prior: 50570212!
test08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: []
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco yaJugoEsteTurno.
		truco cartasMano size = 2.
		"self assert: truco enfrentamientosGanadosMano equals: 1.
		self assert: truco enfrentamientosGanadosPie equals: 0." ]
		! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:08:40' prior: 50570234!
test08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: []
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco yaJugoEsteTurno.
		truco cartasMano size = 2.
		truco cartasPie size = 3.
		"self assert: truco enfrentamientosGanadosMano equals: 1.
		self assert: truco enfrentamientosGanadosPie equals: 0." ]
		! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:09:08' prior: 50570257!
test08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: []
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco comienzaGanadorAnterior.
		truco cartasMano size = 2.
		truco cartasPie size = 3.
		"self assert: truco enfrentamientosGanadosMano equals: 1.
		self assert: truco enfrentamientosGanadosPie equals: 0." ]
		! !
!RondaDeTruco class methodsFor: 'error-message' stamp: 'MY 7/4/2022 02:09:35'!
comienzaGanadorAnterior
	
	^ 'Debe comenzar el enfrentamiento el ganador del anterior'! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:10:17' prior: 50570281!
test08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 1)]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco comienzaGanadorAnterior.
		truco cartasMano size = 2.
		truco cartasPie size = 3.
		"self assert: truco enfrentamientosGanadosMano equals: 1.
		self assert: truco enfrentamientosGanadosPie equals: 0." ]
		! !

!testRun: #RondaDeTrucoTest #test08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero stamp: 'MY 7/4/2022 02:10:28'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:14:04'!
xtest08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 1)]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco comienzaGanadorAnterior.
		truco cartasMano size = 2.
		truco cartasPie size = 3.
		"self assert: truco enfrentamientosGanadosMano equals: 1.
		self assert: truco enfrentamientosGanadosPie equals: 0." ]
		! !

!methodRemoval: RondaDeTrucoTest #test08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero stamp: 'MY 7/4/2022 02:14:04'!
test08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 1)]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco comienzaGanadorAnterior.
		truco cartasMano size = 2.
		truco cartasPie size = 3.
		"self assert: truco enfrentamientosGanadosMano equals: 1.
		self assert: truco enfrentamientosGanadosPie equals: 0." ]
		!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:14:23'!
test08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	truco manoJuega: (CartaDeTruco bastoCon: 3).! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:16:05' prior: 50570391!
test08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 2) ]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco manoDeCartasValidas1 ]! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:16:10' prior: 50570405!
test08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 2) ]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco manoDebeArrancarPartida ]! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:17:53'!
test04LaManoDebeArrancarLaPartida

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 2) ]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco manoDebeArrancarPartida ]! !

!methodRemoval: RondaDeTrucoTest #test08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero stamp: 'MY 7/4/2022 02:17:53'!
test08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 2) ]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco manoDebeArrancarPartida ]!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:18:00'!
test05JugarCartaDebeDescontarCartaDeMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	self assert: (truco cartasMano size) equals: 2.
	
	truco pieJuega: (CartaDeTruco espadaCon: 3).
	self assert: (truco cartasPie size) equals: 2.
	! !

!methodRemoval: RondaDeTrucoTest #test04JugarCartaDebeDescontarCartaDeMano stamp: 'MY 7/4/2022 02:18:00'!
test04JugarCartaDebeDescontarCartaDeMano

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	self assert: (truco cartasMano size) equals: 2.
	
	truco pieJuega: (CartaDeTruco espadaCon: 3).
	self assert: (truco cartasPie size) equals: 2.
	!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:18:14'!
test06ManoJuegaCartaCreaPrimerEnfrentamientoConCartaJugada

	| truco cartasMano cartasPie enfrentamiento |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	enfrentamiento := truco enfrentamientoActual.
	self assert: (enfrentamiento isKindOf: PrimerEnfrentamiento).
	self assert: enfrentamiento yaJugoMano equals: true! !

!methodRemoval: RondaDeTrucoTest #test05ManoJuegaCartaCreaPrimerEnfrentamientoConCartaJugada stamp: 'MY 7/4/2022 02:18:14'!
test05ManoJuegaCartaCreaPrimerEnfrentamientoConCartaJugada

	| truco cartasMano cartasPie enfrentamiento |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	enfrentamiento := truco enfrentamientoActual.
	self assert: (enfrentamiento isKindOf: PrimerEnfrentamiento).
	self assert: enfrentamiento yaJugoMano equals: true!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:18:21'!
test07NoDebePoderJugarJugadorDosVecesEnUnTurno

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	
	self should: [truco manoJuega: (CartaDeTruco bastoCon: 3).
		truco manoJuega: (CartaDeTruco bastoCon: 2).]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco yaJugoEsteTurno ]
	! !

!methodRemoval: RondaDeTrucoTest #test06NoDebePoderJugarJugadorDosVecesEnUnTurno stamp: 'MY 7/4/2022 02:18:21'!
test06NoDebePoderJugarJugadorDosVecesEnUnTurno

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	
	self should: [truco manoJuega: (CartaDeTruco bastoCon: 3).
		truco manoJuega: (CartaDeTruco bastoCon: 2).]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco yaJugoEsteTurno ]
	!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:18:29'!
test08JugarPieEnPrimerEnfrentamientoDebeAumentarEnfrentamientosGanadosDeGanador

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self assert: truco enfrentamientosGanadosMano equals: 1.
	self assert: truco enfrentamientosGanadosPie equals: 0.! !

!methodRemoval: RondaDeTrucoTest #test07JugarPieEnPrimerEnfrentamientoDebeAumentarEnfrentamientosGanadosDeGanador stamp: 'MY 7/4/2022 02:18:29'!
test07JugarPieEnPrimerEnfrentamientoDebeAumentarEnfrentamientosGanadosDeGanador

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self assert: truco enfrentamientosGanadosMano equals: 1.
	self assert: truco enfrentamientosGanadosPie equals: 0.!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:18:37'!
xtest09NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 1)]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco comienzaGanadorAnterior.
		truco cartasMano size = 2.
		truco cartasPie size = 3.
		"self assert: truco enfrentamientosGanadosMano equals: 1.
		self assert: truco enfrentamientosGanadosPie equals: 0." ]
		! !

!methodRemoval: RondaDeTrucoTest #xtest08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero stamp: 'MY 7/4/2022 02:18:37'!
xtest08NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 1)]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco comienzaGanadorAnterior.
		truco cartasMano size = 2.
		truco cartasPie size = 3.
		"self assert: truco enfrentamientosGanadosMano equals: 1.
		self assert: truco enfrentamientosGanadosPie equals: 0." ]
		!

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 7/4/2022 02:18:39'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 7/4/2022 02:18:39'!
PASSED!

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 7/4/2022 02:18:39'!
PASSED!

!testRun: #RondaDeTrucoTest #test04LaManoDebeArrancarLaPartida stamp: 'MY 7/4/2022 02:18:39'!
FAILURE!

!testRun: #RondaDeTrucoTest #test05JugarCartaDebeDescontarCartaDeMano stamp: 'MY 7/4/2022 02:18:39'!
PASSED!

!testRun: #RondaDeTrucoTest #test06ManoJuegaCartaCreaPrimerEnfrentamientoConCartaJugada stamp: 'MY 7/4/2022 02:18:39'!
PASSED!

!testRun: #RondaDeTrucoTest #test07NoDebePoderJugarJugadorDosVecesEnUnTurno stamp: 'MY 7/4/2022 02:18:39'!
PASSED!

!testRun: #RondaDeTrucoTest #test08JugarPieEnPrimerEnfrentamientoDebeAumentarEnfrentamientosGanadosDeGanador stamp: 'MY 7/4/2022 02:18:39'!
PASSED!

!testRun: #RondaDeTrucoTest #test04LaManoDebeArrancarLaPartida stamp: 'MY 7/4/2022 02:18:39'!
FAILURE!

!testRun: #RondaDeTrucoTest #test04LaManoDebeArrancarLaPartida stamp: 'MY 7/4/2022 02:20:46'!
FAILURE!
!RondaDeTruco class methodsFor: 'error-message' stamp: 'MY 7/4/2022 02:21:15'!
manoDebeArrancarPartida
	
	^ 'El primer enfrentamiento de la partida lo debe arrancar la mano'! !
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 7/4/2022 02:26:28' prior: 50570023!
manoJuega: aCartaDeTruco 
	
	(enfrentamiento isNil) ifTrue: [enfrentamiento := enfrentamiento initializeConCarta: aCartaDeTruco]
	ifFalse: [self validarManoNoJugoEsteTurno.].
	self jugar: aCartaDeTruco con: mano.! !
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 7/4/2022 02:27:05' prior: 50570711!
manoJuega: aCartaDeTruco 
	
	self validarManoNoJugoEsteTurno.
	enfrentamiento := enfrentamiento initializeConCarta: aCartaDeTruco.
	self jugar: aCartaDeTruco con: mano.! !
!RondaDeTruco methodsFor: 'initialization' stamp: 'MY 7/4/2022 02:27:24' prior: 50570008!
initializeConMano: cartasMano yPie: cartasPie
 
	mano := cartasMano.
	pie := cartasPie.
	ganadosMano := 0.
	ganadosPie := 0.
	enfrentamiento := PrimerEnfrentamiento new.! !

!methodRemoval: PrimerEnfrentamiento class #conCarta: stamp: 'MY 7/4/2022 02:27:30'!
conCarta: aCartaDeTruco 

	^self new initializeConCarta: aCartaDeTruco !
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 7/4/2022 02:29:07' prior: 50570111!
pieJuega: aCartaDeTruco 
	
	((enfrentamiento isKindOf: PrimerEnfrentamiento) and: (true)) ifTrue: [true].
	self jugar: aCartaDeTruco con: pie.
	enfrentamiento respondeCon: aCartaDeTruco en: self.! !
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 7/4/2022 02:30:36' prior: 50570743!
pieJuega: aCartaDeTruco 
	
	((enfrentamiento isKindOf: PrimerEnfrentamiento) and: (enfrentamiento yaJugoMano = false)) ifTrue: [RondaDeTruco manoDebeArrancarPartida ].
	self jugar: aCartaDeTruco con: pie.
	enfrentamiento respondeCon: aCartaDeTruco en: self.! !

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 7/4/2022 02:32:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 7/4/2022 02:32:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 7/4/2022 02:32:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test04LaManoDebeArrancarLaPartida stamp: 'MY 7/4/2022 02:32:16'!
FAILURE!

!testRun: #RondaDeTrucoTest #test05JugarCartaDebeDescontarCartaDeMano stamp: 'MY 7/4/2022 02:32:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test06ManoJuegaCartaCreaPrimerEnfrentamientoConCartaJugada stamp: 'MY 7/4/2022 02:32:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test07NoDebePoderJugarJugadorDosVecesEnUnTurno stamp: 'MY 7/4/2022 02:32:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test08JugarPieEnPrimerEnfrentamientoDebeAumentarEnfrentamientosGanadosDeGanador stamp: 'MY 7/4/2022 02:32:16'!
PASSED!

!testRun: #RondaDeTrucoTest #test04LaManoDebeArrancarLaPartida stamp: 'MY 7/4/2022 02:32:16'!
FAILURE!
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 7/4/2022 02:34:26' prior: 50570752!
pieJuega: aCartaDeTruco 
	
	(self esPrimerEnfrentamientoYManoNoJugo) ifTrue: [RondaDeTruco manoDebeArrancarPartida ].
	self jugar: aCartaDeTruco con: pie.
	enfrentamiento respondeCon: aCartaDeTruco en: self.! !
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 7/4/2022 02:34:40'!
esPrimerEnfrentamientoYManoNoJugo

	^(enfrentamiento isKindOf: PrimerEnfrentamiento) and: (enfrentamiento yaJugoMano = false)! !
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 7/4/2022 02:34:43' prior: 50570805!
esPrimerEnfrentamientoYManoNoJugo

	^ (enfrentamiento isKindOf: PrimerEnfrentamiento) and: (enfrentamiento yaJugoMano = false)! !
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 7/4/2022 02:35:12'!
validarPieDebeJugar

	^ (self esPrimerEnfrentamientoYManoNoJugo) ifTrue: [RondaDeTruco manoDebeArrancarPartida ]! !
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 7/4/2022 02:35:12' prior: 50570796!
pieJuega: aCartaDeTruco 
	
	self validarPieDebeJugar.
	self jugar: aCartaDeTruco con: pie.
	enfrentamiento respondeCon: aCartaDeTruco en: self.! !

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 7/4/2022 02:35:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 7/4/2022 02:35:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 7/4/2022 02:35:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test04LaManoDebeArrancarLaPartida stamp: 'MY 7/4/2022 02:35:20'!
FAILURE!

!testRun: #RondaDeTrucoTest #test05JugarCartaDebeDescontarCartaDeMano stamp: 'MY 7/4/2022 02:35:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test06ManoJuegaCartaCreaPrimerEnfrentamientoConCartaJugada stamp: 'MY 7/4/2022 02:35:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test07NoDebePoderJugarJugadorDosVecesEnUnTurno stamp: 'MY 7/4/2022 02:35:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test08JugarPieEnPrimerEnfrentamientoDebeAumentarEnfrentamientosGanadosDeGanador stamp: 'MY 7/4/2022 02:35:20'!
PASSED!

!testRun: #RondaDeTrucoTest #test04LaManoDebeArrancarLaPartida stamp: 'MY 7/4/2022 02:35:20'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:35:51' prior: 50570442!
test04LaManoDebeArrancarLaPartida

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 2) ]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco manoDebeArrancarPartida ]! !

!testRun: #RondaDeTrucoTest #test04LaManoDebeArrancarLaPartida stamp: 'MY 7/4/2022 02:35:52'!
ERROR!
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 7/4/2022 02:36:53' prior: 50570812!
esPrimerEnfrentamientoYManoNoJugo

	^ (enfrentamiento class isKindOf: PrimerEnfrentamiento) and: (enfrentamiento yaJugoMano = false)! !

!testRun: #RondaDeTrucoTest #test04LaManoDebeArrancarLaPartida stamp: 'MY 7/4/2022 02:36:54'!
ERROR!

!testRun: #RondaDeTrucoTest #test04LaManoDebeArrancarLaPartida stamp: 'MY 7/4/2022 02:36:59'!
ERROR!

self class isKindOf: PrimerEnfrentamiento !

self class = PrimerEnfrentamiento !

self isKindOf: PrimerEnfrentamiento !

self isKindOf: PrimerEnfrentamiento!
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 7/4/2022 02:38:09' prior: 50570886!
esPrimerEnfrentamientoYManoNoJugo

	^ (enfrentamiento isKindOf: PrimerEnfrentamiento) and: (enfrentamiento yaJugoMano = false)! !
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 7/4/2022 02:39:09' prior: 50570819!
validarPieDebeJugar

	^ (self esPrimerEnfrentamientoYManoNoJugo) ifTrue: [^ self error: RondaDeTruco manoDebeArrancarPartida ]! !

!testRun: #RondaDeTrucoTest #test04LaManoDebeArrancarLaPartida stamp: 'MY 7/4/2022 02:39:13'!
PASSED!

!testRun: #RondaDeTrucoTest #test04LaManoDebeArrancarLaPartida stamp: 'MY 7/4/2022 02:39:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 7/4/2022 02:39:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 7/4/2022 02:39:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 7/4/2022 02:39:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test04LaManoDebeArrancarLaPartida stamp: 'MY 7/4/2022 02:39:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test05JugarCartaDebeDescontarCartaDeMano stamp: 'MY 7/4/2022 02:39:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test06ManoJuegaCartaCreaPrimerEnfrentamientoConCartaJugada stamp: 'MY 7/4/2022 02:39:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test07NoDebePoderJugarJugadorDosVecesEnUnTurno stamp: 'MY 7/4/2022 02:39:17'!
PASSED!

!testRun: #RondaDeTrucoTest #test08JugarPieEnPrimerEnfrentamientoDebeAumentarEnfrentamientosGanadosDeGanador stamp: 'MY 7/4/2022 02:39:17'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:39:57'!
test09NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 1)]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco comienzaGanadorAnterior.
		truco cartasMano size = 2.
		truco cartasPie size = 3.
		"self assert: truco enfrentamientosGanadosMano equals: 1.
		self assert: truco enfrentamientosGanadosPie equals: 0." ]
		! !

!methodRemoval: RondaDeTrucoTest #xtest09NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero stamp: 'MY 7/4/2022 02:39:57'!
xtest09NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 1)]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco comienzaGanadorAnterior.
		truco cartasMano size = 2.
		truco cartasPie size = 3.
		"self assert: truco enfrentamientosGanadosMano equals: 1.
		self assert: truco enfrentamientosGanadosPie equals: 0." ]
		!

!testRun: #RondaDeTrucoTest #test09NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero stamp: 'MY 7/4/2022 02:39:58'!
FAILURE!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:40:43'!
xtest09NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 1)]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco comienzaGanadorAnterior.
		truco cartasMano size = 2.
		truco cartasPie size = 3.
		"self assert: truco enfrentamientosGanadosMano equals: 1.
		self assert: truco enfrentamientosGanadosPie equals: 0." ]
		! !

!methodRemoval: RondaDeTrucoTest #test09NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero stamp: 'MY 7/4/2022 02:40:43'!
test09NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 1)]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco comienzaGanadorAnterior.
		truco cartasMano size = 2.
		truco cartasPie size = 3.
		"self assert: truco enfrentamientosGanadosMano equals: 1.
		self assert: truco enfrentamientosGanadosPie equals: 0." ]
		!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:41:37'!
test09DespuesDeJugarPieEnPrimerEnfrentamientoDebeCrearSegundoEnfrentamiento

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 1)]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco comienzaGanadorAnterior.
		truco cartasMano size = 2.
		truco cartasPie size = 3.
		"self assert: truco enfrentamientosGanadosMano equals: 1.
		self assert: truco enfrentamientosGanadosPie equals: 0." ]
		! !

!classDefinition: #SegundoEnfrentamiento category: 'ISW1-2021-1C-2doParcial' stamp: 'MY 7/4/2022 02:42:31'!
Enfrentamiento subclass: #SegundoEnfrentamiento
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:42:22' prior: 50571061!
test09DespuesDeJugarPieEnPrimerEnfrentamientoDebeCrearSegundoEnfrentamiento

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self assert: ((truco enfrentamientoActual) isKindOf: SegundoEnfrentamiento).! !
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:42:34' prior: 50571096!
test09DespuesDeJugarPieEnPrimerEnfrentamientoDebeCrearSegundoEnfrentamiento

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self assert: ((truco enfrentamientoActual) isKindOf: SegundoEnfrentamiento).! !

!testRun: #RondaDeTrucoTest #test09DespuesDeJugarPieEnPrimerEnfrentamientoDebeCrearSegundoEnfrentamiento stamp: 'MY 7/4/2022 02:42:34'!
FAILURE!

!testRun: #RondaDeTrucoTest #test09DespuesDeJugarPieEnPrimerEnfrentamientoDebeCrearSegundoEnfrentamiento stamp: 'MY 7/4/2022 02:42:38'!
FAILURE!
!PrimerEnfrentamiento methodsFor: 'playing' stamp: 'MY 7/4/2022 02:43:56' prior: 50570118!
respondeCon: aCartaDeTruco en: aRondaDeTruco 
	
	(aCartaDeTruco mataA: cartaMano) ifTrue: [ aRondaDeTruco pieGanoEnfrentamiento ]
	ifFalse: [ aRondaDeTruco manoGanoEnfrentamiento ].
	^ aRondaDeTruco nuevoEnfrentamiento: self proximoEnfrentamiento.! !
!PrimerEnfrentamiento methodsFor: 'comparing' stamp: 'MY 7/4/2022 02:44:23'!
proximoEnfrentamiento
	
	^ SegundoEnfrentamiento.! !
!RondaDeTruco methodsFor: 'playing' stamp: 'MY 7/4/2022 02:45:14'!
nuevoEnfrentamiento: anEnfrentamiento

	enfrentamiento := anEnfrentamiento new.! !

!testRun: #RondaDeTrucoTest #test09DespuesDeJugarPieEnPrimerEnfrentamientoDebeCrearSegundoEnfrentamiento stamp: 'MY 7/4/2022 02:45:18'!
PASSED!

!testRun: #RondaDeTrucoTest #test01LaRondaDebeLanzarErrorSiNoComenzarConTresCartas stamp: 'MY 7/4/2022 02:45:18'!
PASSED!

!testRun: #RondaDeTrucoTest #test02LaRondaComienzaSinCartasRepetidas stamp: 'MY 7/4/2022 02:45:18'!
PASSED!

!testRun: #RondaDeTrucoTest #test03NoSePuedeJugarCartaQueNoEsteEnMano stamp: 'MY 7/4/2022 02:45:18'!
PASSED!

!testRun: #RondaDeTrucoTest #test04LaManoDebeArrancarLaPartida stamp: 'MY 7/4/2022 02:45:18'!
PASSED!

!testRun: #RondaDeTrucoTest #test05JugarCartaDebeDescontarCartaDeMano stamp: 'MY 7/4/2022 02:45:18'!
PASSED!

!testRun: #RondaDeTrucoTest #test06ManoJuegaCartaCreaPrimerEnfrentamientoConCartaJugada stamp: 'MY 7/4/2022 02:45:18'!
PASSED!

!testRun: #RondaDeTrucoTest #test07NoDebePoderJugarJugadorDosVecesEnUnTurno stamp: 'MY 7/4/2022 02:45:18'!
PASSED!

!testRun: #RondaDeTrucoTest #test08JugarPieEnPrimerEnfrentamientoDebeAumentarEnfrentamientosGanadosDeGanador stamp: 'MY 7/4/2022 02:45:18'!
PASSED!

!testRun: #RondaDeTrucoTest #test09DespuesDeJugarPieEnPrimerEnfrentamientoDebeCrearSegundoEnfrentamiento stamp: 'MY 7/4/2022 02:45:18'!
PASSED!
!RondaDeTrucoTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 02:45:41'!
xtest10NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 1)]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco comienzaGanadorAnterior.
		truco cartasMano size = 2.
		truco cartasPie size = 3.
		"self assert: truco enfrentamientosGanadosMano equals: 1.
		self assert: truco enfrentamientosGanadosPie equals: 0." ]
		! !

!methodRemoval: RondaDeTrucoTest #xtest09NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero stamp: 'MY 7/4/2022 02:45:41'!
xtest09NoPuedeJugarSegundoEnfrentamientoPerdedorDelPrimero

	| truco cartasMano cartasPie |
	
	cartasMano := self manoDeCartasValidas1.
	cartasPie := self manoDeCartasValidas2.
	truco := RondaDeTruco withMano: cartasMano yPie: cartasPie.
	truco manoJuega: (CartaDeTruco bastoCon: 3).
	truco pieJuega: (CartaDeTruco espadaCon: 2).
	
	self should: [ truco pieJuega: (CartaDeTruco espadaCon: 1)]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError | anError messageText = RondaDeTruco comienzaGanadorAnterior.
		truco cartasMano size = 2.
		truco cartasPie size = 3.
		"self assert: truco enfrentamientosGanadosMano equals: 1.
		self assert: truco enfrentamientosGanadosPie equals: 0." ]
		!

----SNAPSHOT----(4 July 2022 02:46:35) CuisUniversity-5324.image priorSource: 7601032!

----STARTUP---- (4 July 2022 17:32:47) as C:\Users\Maxi\Desktop\Facultad\Inge1\cuisNuevo\windows64\CuisUniversity-5324.image!


!classRemoval: #RondaDeTruco stamp: 'MY 7/4/2022 17:32:58'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'mano pie enfrentamiento ganadosMano ganadosPie'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #SegundoEnfrentamiento stamp: 'MY 7/4/2022 17:32:58'!
Enfrentamiento subclass: #SegundoEnfrentamiento
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #PrimerEnfrentamiento stamp: 'MY 7/4/2022 17:32:58'!
Enfrentamiento subclass: #PrimerEnfrentamiento
	instanceVariableNames: 'cartaMano'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #Enfrentamiento stamp: 'MY 7/4/2022 17:32:59'!
Object subclass: #Enfrentamiento
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #CartaDeTruco stamp: 'MY 7/4/2022 17:32:59'!
Object subclass: #CartaDeTruco
	instanceVariableNames: 'palo numero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #RondaDeTrucoTest stamp: 'MY 7/4/2022 17:32:59'!
TestCase subclass: #RondaDeTrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #CartaDeTrucoTest stamp: 'MY 7/4/2022 17:32:59'!
TestCase subclass: #CartaDeTrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

Object subclass: #LaddersAndSlides
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #LaddersAndSlides category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 17:34:12'!
Object subclass: #LaddersAndSlides
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

TestCase subclass: #LaddersAndSlidesTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #LaddersAndSlidesTest category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 17:34:20'!
TestCase subclass: #LaddersAndSlidesTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!LaddersAndSlidesTest methodsFor: 'nil' stamp: 'MY 7/4/2022 17:34:29'!
test01! !

Random new!

(1 to :10) atRandom!

(1 to: 10) atRandom!

(1 to: 10) atRandom !

(1 to: 10) atRandom !

(1 to: 10) atRandom !

(1 to: 10) atRandom !

(1 to: 10) atRandom !

(1 to: 10) atRandom !

(1 to: 10) atRandom !

(1 to: 10) atRandom !

(1 to: 10) atRandom !

1@2@1!

1@2!

(1@2) type!

(1@2) class!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 17:49:36'!
test01FloorMustHaveALadder! !

----End fileIn of C:\Users\Maxi\Desktop\Facultad\Inge1\cuisNuevo\windows64\ISW1-2021-1C-2doParcial-Resolucion-ConRondaDeTrucoyTurno.st----!

----End fileIn of C:\Users\Maxi\Desktop\Facultad\Inge1\cuisNuevo\windows64\ISW1-2021-1C-2doParcial.st----!

!classRemoval: #TerminaPie stamp: 'MY 7/4/2022 17:54:41'!
Turno subclass: #TerminaPie
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

!classRemoval: #TerminaMano stamp: 'MY 7/4/2022 17:54:42'!
Turno subclass: #TerminaMano
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

!classRemoval: #RondaFinalizada stamp: 'MY 7/4/2022 17:54:42'!
Turno subclass: #RondaFinalizada
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

!classRemoval: #ComienzaPie stamp: 'MY 7/4/2022 17:54:42'!
Turno subclass: #ComienzaPie
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

!classRemoval: #ComienzaMano stamp: 'MY 7/4/2022 17:54:42'!
Turno subclass: #ComienzaMano
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

!classRemoval: #Turno stamp: 'MY 7/4/2022 17:54:42'!
Object subclass: #Turno
	instanceVariableNames: 'ronda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

!classRemoval: #TrucoTest stamp: 'MY 7/4/2022 17:54:43'!
TestCase subclass: #TrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

!classRemoval: #RondaDeTruco stamp: 'MY 7/4/2022 17:54:43'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'mano pie enfrentamiento ganadosMano ganadosPie'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #SegundoEnfrentamiento stamp: 'MY 7/4/2022 17:54:44'!
Enfrentamiento subclass: #SegundoEnfrentamiento
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #PrimerEnfrentamiento stamp: 'MY 7/4/2022 17:54:44'!
Enfrentamiento subclass: #PrimerEnfrentamiento
	instanceVariableNames: 'cartaMano'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #Enfrentamiento stamp: 'MY 7/4/2022 17:54:44'!
Object subclass: #Enfrentamiento
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #CartaDeTruco stamp: 'MY 7/4/2022 17:54:44'!
Object subclass: #CartaDeTruco
	instanceVariableNames: 'palo numero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #RondaDeTrucoTest stamp: 'MY 7/4/2022 17:54:45'!
TestCase subclass: #RondaDeTrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #CartaDeTrucoTest stamp: 'MY 7/4/2022 17:54:45'!
TestCase subclass: #CartaDeTrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

----End fileIn of C:\Users\Maxi\Desktop\Facultad\Inge1\Parciales\2021-1c\2doParcial\ISW1-2021-1C-2doParcial-Resolucion.st----!

Object subclass: #RectangularFloor
	instanceVariableNames: 'map floor slides ladders'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #RectangularFloor category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:01:33'!
Object subclass: #RectangularFloor
	instanceVariableNames: 'map floor slides ladders'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

Object subclass: #Slide
	instanceVariableNames: 'map floor slides ladders'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Slide category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:01:44'!
Object subclass: #Slide
	instanceVariableNames: 'map floor slides ladders'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

Object subclass: #Slide
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Slide category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:01:48'!
Object subclass: #Slide
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

Object subclass: #Ladder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Ladder category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:01:51'!
Object subclass: #Ladder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

Object subclass: #Ladder
	instanceVariableNames: 'origin destination'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Ladder category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:02:21'!
Object subclass: #Ladder
	instanceVariableNames: 'origin destination'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

Object subclass: #Slide
	instanceVariableNames: 'origin destination'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Slide category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:02:27'!
Object subclass: #Slide
	instanceVariableNames: 'origin destination'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

TestCase subclass: #RectangularFloorTest
	instanceVariableNames: 'map floor slides ladders'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #RectangularFloorTest category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:03:10'!
TestCase subclass: #RectangularFloorTest
	instanceVariableNames: 'map floor slides ladders'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

TestCase subclass: #RectangularFloorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #RectangularFloorTest category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:03:19'!
TestCase subclass: #RectangularFloorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!RectangularFloor class methodsFor: 'nil' stamp: 'MY 7/4/2022 18:05:56'!
ofHeight: aHeight andWidth: aWidth

	^ self new ofHeight: aHeight andWidth: aWidth.! !
!RectangularFloor methodsFor: 'nil' stamp: 'MY 7/4/2022 18:06:39'!
ofHeight: aHeight andWidth: aWidth

	map := Rectangle origin: aHeight corner: aWidth ! !
!RectangularFloor methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:08:29' prior: 50576120!
ofHeight: aHeight andWidth: aWidth

	map := Rectangle origin: 1@aHeight corner: aWidth@1. ! !
!RectangularFloor methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:08:42'!
map
	
	^map.! !
!RectangularFloorTest methodsFor: 'no messages' stamp: 'MY 7/4/2022 18:09:38'!
test01

	| floor |
	
	floor := RectangularFloor ofHeight: 5  andWidth: 4.
	
	^self assert: [floor map ]! !

!classRemoval: #RondaDeTruco stamp: 'MY 7/4/2022 18:09:46'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'cartasDeManoDisponibles cartasDePieDisponibles enfrentamientoActual'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #JuegaPie stamp: 'MY 7/4/2022 18:09:47'!
EstadoDeEnfrentamiento subclass: #JuegaPie
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #JuegaMano stamp: 'MY 7/4/2022 18:09:47'!
EstadoDeEnfrentamiento subclass: #JuegaMano
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #EnfrentamientoTerminado stamp: 'MY 7/4/2022 18:09:47'!
EstadoDeEnfrentamiento subclass: #EnfrentamientoTerminado
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #EmpiezaPie stamp: 'MY 7/4/2022 18:09:47'!
EstadoDeEnfrentamiento subclass: #EmpiezaPie
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #EmpiezaMano stamp: 'MY 7/4/2022 18:09:48'!
EstadoDeEnfrentamiento subclass: #EmpiezaMano
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #EstadoDeEnfrentamiento stamp: 'MY 7/4/2022 18:09:48'!
Object subclass: #EstadoDeEnfrentamiento
	instanceVariableNames: 'enfrentamiento'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #RondaDeTrucoTerminada stamp: 'MY 7/4/2022 18:09:48'!
EnfrentamientoDeTruco subclass: #RondaDeTrucoTerminada
	instanceVariableNames: 'anterior'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #PrimerEnfrentamientoDeTruco stamp: 'MY 7/4/2022 18:09:48'!
EnfrentamientoDeTrucoConCartas subclass: #PrimerEnfrentamientoDeTruco
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #EnfrentamientoDeTrucoPosteriorAlPrimero stamp: 'MY 7/4/2022 18:09:49'!
EnfrentamientoDeTrucoConCartas subclass: #EnfrentamientoDeTrucoPosteriorAlPrimero
	instanceVariableNames: 'anterior'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #EnfrentamientoDeTrucoConCartas stamp: 'MY 7/4/2022 18:09:49'!
EnfrentamientoDeTruco subclass: #EnfrentamientoDeTrucoConCartas
	instanceVariableNames: 'cartaDeMano cartaDePie estado'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #EnfrentamientoDeTruco stamp: 'MY 7/4/2022 18:09:49'!
Object subclass: #EnfrentamientoDeTruco
	instanceVariableNames: 'ronda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #CartaDeTruco stamp: 'MY 7/4/2022 18:09:49'!
Object subclass: #CartaDeTruco
	instanceVariableNames: 'palo numero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #TrucoTest stamp: 'MY 7/4/2022 18:09:50'!
TestCase subclass: #TrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #CartaDeTrucoTest stamp: 'MY 7/4/2022 18:09:50'!
TestCase subclass: #CartaDeTrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:11:14' prior: 50576135!
test01

	| floor |
	
	floor := RectangularFloor ofHeight: 5  andWidth: 4.
	
	^self assert: [floor map height = 5.
		floor map width = 4 ]! !

!testRun: #RectangularFloorTest #test01 stamp: 'MY 7/4/2022 18:11:15'!
FAILURE!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:12:15' prior: 50576257!
test01

	| floor |
	
	floor := RectangularFloor ofHeight: 5  andWidth: 4.
	
	^self assert: [floor map height = 4.
		floor map width = 3 ]! !

!testRun: #RectangularFloorTest #test01 stamp: 'MY 7/4/2022 18:12:16'!
PASSED!

!testRun: #RectangularFloorTest #test01 stamp: 'MY 7/4/2022 18:12:16'!
PASSED!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:13:47' prior: 50576268!
test01

	| floor |
	
	floor := RectangularFloor ofHeight: 5  andWidth: 4.
	
	^self assert: [floor map height = 5.
		floor map width = 4 ]! !
!RectangularFloor class methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:14:01' prior: 50576115!
ofHeight: aHeight andWidth: aWidth

	^ self new ofHeight: (aHeight+1) andWidth: (aWidth+1).! !

!testRun: #RectangularFloorTest #test01 stamp: 'MY 7/4/2022 18:14:07'!
PASSED!

!testRun: #RectangularFloorTest #test01 stamp: 'MY 7/4/2022 18:14:07'!
PASSED!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:15:02'!
test02FloorMustHaveANumber

	| floor |
	
	floor := RectangularFloor number: 1 ofHeight: 5 andWidth: 4.
	
	^self assert: [ floor number = 1 ]! !

!testRun: #RectangularFloorTest #test02FloorMustHaveANumber stamp: 'MY 7/4/2022 18:15:03'!
ERROR!
!RectangularFloor class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:15:10'!
number: aSmallInteger ofHeight: aSmallInteger2 andWidth: aSmallInteger3 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeNumber: aSmallInteger ofHeight: aSmallInteger2 andWidth: aSmallInteger3 ! !
!RectangularFloor class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:15:46' prior: 50576311!
number: aNumber ofHeight: aHeight andWidth: aWidth 
	
	^self new floor: aNumber ofHeight: aHeight andWidth: aWidth. ! !

!testRun: #RectangularFloorTest #test02FloorMustHaveANumber stamp: 'MY 7/4/2022 18:15:50'!
ERROR!
!RectangularFloor methodsFor: 'initialize' stamp: 'MY 7/4/2022 18:16:09'!
floor: aSmallInteger ofHeight: aSmallInteger2 andWidth: aSmallInteger3 
	self shouldBeImplemented.! !
!RectangularFloor methodsFor: 'initialize' stamp: 'MY 7/4/2022 18:16:33' prior: 50576333!
floor: aNumber ofHeight: aHeight andWidth: aWidth 
	
	floor := aNumber.! !
!RectangularFloor class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:16:59' prior: 50576323!
number: aNumber ofHeight: aHeight andWidth: aWidth 
	
	^self new floor: aNumber ofHeight: (aHeight+1) andWidth: (aWidth+1). ! !
!RectangularFloor methodsFor: 'initialize' stamp: 'MY 7/4/2022 18:17:19' prior: 50576339!
floor: aNumber ofHeight: aHeight andWidth: aWidth 
	
	map := Rectangle origin: 1@aHeight corner: aWidth@1.
	floor := aNumber.! !

!methodRemoval: RectangularFloor #ofHeight:andWidth: stamp: 'MY 7/4/2022 18:17:23'!
ofHeight: aHeight andWidth: aWidth

	map := Rectangle origin: 1@aHeight corner: aWidth@1. !

!methodRemoval: RectangularFloor class #ofHeight:andWidth: stamp: 'MY 7/4/2022 18:17:28'!
ofHeight: aHeight andWidth: aWidth

	^ self new ofHeight: (aHeight+1) andWidth: (aWidth+1).!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:17:45'!
test01FloorMustHaveMapAndLevelNumber

	| floor |
	
	floor := RectangularFloor ofHeight: 5  andWidth: 4.
	
	^self assert: [floor map height = 5.
		floor map width = 4 ]! !
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:18:05' prior: 50576371!
test01FloorMustHaveMapAndLevelNumber

	| floor |
	
	floor := RectangularFloor number: 1 ofHeight: 5 andWidth: 4.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor number = 1  ]! !

!testRun: #RectangularFloorTest #test01FloorMustHaveMapAndLevelNumber stamp: 'MY 7/4/2022 18:18:07'!
ERROR!

!methodRemoval: RectangularFloorTest #test02FloorMustHaveANumber stamp: 'MY 7/4/2022 18:18:11'!
test02FloorMustHaveANumber

	| floor |
	
	floor := RectangularFloor number: 1 ofHeight: 5 andWidth: 4.
	
	^self assert: [ floor number = 1 ]!

!methodRemoval: RectangularFloorTest #test01 stamp: 'MY 7/4/2022 18:18:18'!
test01

	| floor |
	
	floor := RectangularFloor ofHeight: 5  andWidth: 4.
	
	^self assert: [floor map height = 5.
		floor map width = 4 ]!

!testRun: #RectangularFloorTest #test01FloorMustHaveMapAndLevelNumber stamp: 'MY 7/4/2022 18:18:19'!
ERROR!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:18:32' prior: 50576380!
test01FloorMustHaveMapAndLevelNumber

	| floor |
	
	floor := RectangularFloor number: 1 ofHeight: 5 andWidth: 4.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1  ]! !
!RectangularFloor class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:19:07'!
level: aNumber ofHeight: aHeight andWidth: aWidth 
	
	^self new floor: aNumber ofHeight: (aHeight+1) andWidth: (aWidth+1). ! !
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:19:07' prior: 50576411!
test01FloorMustHaveMapAndLevelNumber

	| floor |
	
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1  ]! !

!methodRemoval: RectangularFloor class #number:ofHeight:andWidth: stamp: 'MY 7/4/2022 18:19:07'!
number: aNumber ofHeight: aHeight andWidth: aWidth 
	
	^self new floor: aNumber ofHeight: (aHeight+1) andWidth: (aWidth+1). !

!testRun: #RectangularFloorTest #test01FloorMustHaveMapAndLevelNumber stamp: 'MY 7/4/2022 18:19:12'!
ERROR!
!RectangularFloor methodsFor: 'accessing' stamp: 'MY 7/4/2022 18:19:17'!
level
	self shouldBeImplemented.! !

!classDefinition: #RectangularFloor category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:19:23'!
Object subclass: #RectangularFloor
	instanceVariableNames: 'map floor slides ladders level'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!RectangularFloor methodsFor: 'accessing' stamp: 'MY 7/4/2022 18:19:22' prior: 50576448!
level
	
	^level! !
!RectangularFloor methodsFor: 'initialize' stamp: 'MY 7/4/2022 18:19:37' prior: 50576352!
floor: aNumber ofHeight: aHeight andWidth: aWidth 
	
	map := Rectangle origin: 1@aHeight corner: aWidth@1.
	level := aNumber.! !

Object subclass: #RectangularFloor
	instanceVariableNames: 'map slides ladders level'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #RectangularFloor category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:19:44'!
Object subclass: #RectangularFloor
	instanceVariableNames: 'map slides ladders level'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!testRun: #RectangularFloorTest #test01FloorMustHaveMapAndLevelNumber stamp: 'MY 7/4/2022 18:19:48'!
PASSED!

!testRun: #RectangularFloorTest #test01FloorMustHaveMapAndLevelNumber stamp: 'MY 7/4/2022 18:19:48'!
PASSED!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:22:00'!
test02FloorMustHaveAListOfLadders

	| floor ladders |
	
	ladders := OrderedCollection new with: (Ladder new).
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1 ].! !

!testRun: #RectangularFloorTest #test02FloorMustHaveAListOfLadders stamp: 'MY 7/4/2022 18:22:19'!
ERROR!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:22:52' prior: 50576493!
test02FloorMustHaveAListOfLadders

	| floor ladders |
	
	ladders := OrderedCollection newFrom: #(Ladder new).
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1 ].! !

!testRun: #RectangularFloorTest #test02FloorMustHaveAListOfLadders stamp: 'MY 7/4/2022 18:22:54'!
ERROR!
!RectangularFloor class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:23:00'!
level: aSmallInteger ofHeight: aSmallInteger2 andWidth: aSmallInteger3 withLadders: anOrderedCollection 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeLevel: aSmallInteger ofHeight: aSmallInteger2 andWidth: aSmallInteger3 withLadders: anOrderedCollection ! !
!RectangularFloor class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:23:08' prior: 50576526!
level: aSmallInteger ofHeight: aSmallInteger2 andWidth: aSmallInteger3 withLadders: anOrderedCollection 
	
	^self new initializeLevel: aSmallInteger ofHeight: aSmallInteger2 andWidth: aSmallInteger3 withLadders: anOrderedCollection ! !
!RectangularFloor class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:23:53' prior: 50576540!
level: aNumber ofHeight: aHeight andWidth: aWidth withLadders: ladders 
	
	^self new level: aNumber ofHeight: (aHeight+1) andWidth: (aWidth+1) withLadders: ladders. ! !
!RectangularFloor methodsFor: 'initialize' stamp: 'MY 7/4/2022 18:24:20'!
floor: aNumber ofHeight: aHeight andWidth: aWidth withLadders: listOfLadders
	
	map := Rectangle origin: 1@aHeight corner: aWidth@1.
	level := aNumber.
	ladders := listOfLadders! !

!methodRemoval: RectangularFloor #floor:ofHeight:andWidth: stamp: 'MY 7/4/2022 18:24:24'!
floor: aNumber ofHeight: aHeight andWidth: aWidth 
	
	map := Rectangle origin: 1@aHeight corner: aWidth@1.
	level := aNumber.!
!RectangularFloor class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:24:32' prior: 50576551!
level: aNumber ofHeight: aHeight andWidth: aWidth withLadders: listOfLadders 
	
	^self new level: aNumber ofHeight: (aHeight+1) andWidth: (aWidth+1) withLadders: listOfLadders. ! !

!methodRemoval: RectangularFloor class #level:ofHeight:andWidth: stamp: 'MY 7/4/2022 18:24:35'!
level: aNumber ofHeight: aHeight andWidth: aWidth 
	
	^self new floor: aNumber ofHeight: (aHeight+1) andWidth: (aWidth+1). !
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:25:00' prior: 50576429!
test01FloorMustHaveMapAndLevelNumber

	| floor ladders |
	
	ladders := OrderedCollection newFrom: #(Ladder new).
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1  ]! !

!methodRemoval: RectangularFloorTest #test02FloorMustHaveAListOfLadders stamp: 'MY 7/4/2022 18:25:06'!
test02FloorMustHaveAListOfLadders

	| floor ladders |
	
	ladders := OrderedCollection newFrom: #(Ladder new).
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1 ].!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:25:32'!
test01FloorMustHaveAMapALevelNumberAndLadders

	| floor ladders |
	
	ladders := OrderedCollection newFrom: #(Ladder new).
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1  ]! !

!methodRemoval: RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAndLadders stamp: 'MY 7/4/2022 18:25:49'!
test01FloorMustHaveAMapALevelNumberAndLadders

	| floor ladders |
	
	ladders := OrderedCollection newFrom: #(Ladder new).
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1  ]!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:25:52'!
test01FloorMustHaveAMapALevelNumberAndLadders

	| floor ladders |
	
	ladders := OrderedCollection newFrom: #(Ladder new).
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1  ]! !

!methodRemoval: RectangularFloorTest #test01FloorMustHaveMapAndLevelNumber stamp: 'MY 7/4/2022 18:25:52'!
test01FloorMustHaveMapAndLevelNumber

	| floor ladders |
	
	ladders := OrderedCollection newFrom: #(Ladder new).
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1  ]!
!RectangularFloor methodsFor: 'initialize' stamp: 'MY 7/4/2022 18:26:10'!
level: aNumber ofHeight: aHeight andWidth: aWidth withLadders: listOfLadders
	
	map := Rectangle origin: 1@aHeight corner: aWidth@1.
	level := aNumber.
	ladders := listOfLadders! !

!methodRemoval: RectangularFloor #floor:ofHeight:andWidth:withLadders: stamp: 'MY 7/4/2022 18:26:10'!
floor: aNumber ofHeight: aHeight andWidth: aWidth withLadders: listOfLadders
	
	map := Rectangle origin: 1@aHeight corner: aWidth@1.
	level := aNumber.
	ladders := listOfLadders!
!RectangularFloor methodsFor: 'accessing' stamp: 'MY 7/4/2022 18:26:22'!
ladders
	
	^ladders ! !

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAndLadders stamp: 'MY 7/4/2022 18:26:25'!
FAILURE!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:27:18' prior: 50576644!
test01FloorMustHaveAMapALevelNumberAndLadders

	| floor ladders ladder |
	
	ladder := Ladder new.
	ladders := OrderedCollection newFrom: #(ladder).
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1  ]! !

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAndLadders stamp: 'MY 7/4/2022 18:27:21'!
PASSED!

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAndLadders stamp: 'MY 7/4/2022 18:27:21'!
PASSED!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:27:54' prior: 50576695!
test01FloorMustHaveAMapALevelNumberAndLadders

	| floor ladders ladder |
	
	ladder := Ladder new.
	ladders := OrderedCollection newFrom: (ladder).
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1  ]! !

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAndLadders stamp: 'MY 7/4/2022 18:27:55'!
ERROR!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:28:36' prior: 50576717!
test01FloorMustHaveAMapALevelNumberAndLadders

	| floor ladders |
	ladders := OrderedCollection new add: Ladder new.
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1  ]! !

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAndLadders stamp: 'MY 7/4/2022 18:28:37'!
ERROR!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:29:00' prior: 50576735!
test01FloorMustHaveAMapALevelNumberAndLadders

	| floor ladders |
	ladders := OrderedCollection new add: (Ladder new).
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1  ]! !

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAndLadders stamp: 'MY 7/4/2022 18:29:01'!
ERROR!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:29:28' prior: 50576752!
test01FloorMustHaveAMapALevelNumberAndLadders

	| floor ladders |
	ladders := (OrderedCollection new) add: (Ladder new).
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1  ]! !

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAndLadders stamp: 'MY 7/4/2022 18:29:29'!
ERROR!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:30:13' prior: 50576769!
test01FloorMustHaveAMapALevelNumberAndLadders

	| floor ladders |
	ladders := OrderedCollection new
	ladders add: Ladder new.
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1  ]! !

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAndLadders stamp: 'MY 7/4/2022 18:30:14'!
ERROR!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:30:23' prior: 50576786!
test01FloorMustHaveAMapALevelNumberAndLadders

	| floor ladders |
	ladders := OrderedCollection new.
	ladders add: Ladder new.
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1  ]! !
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:30:33' prior: 50576803!
test01FloorMustHaveAMapALevelNumberAndLadders

	| floor ladders |
	ladders := OrderedCollection new.
	ladders add: Ladder new.
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1  ]! !

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAndLadders stamp: 'MY 7/4/2022 18:30:34'!
PASSED!

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAndLadders stamp: 'MY 7/4/2022 18:30:34'!
PASSED!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:30:36' prior: 50576817!
test01FloorMustHaveAMapALevelNumberAndLadders

	| floor ladders |
	
	ladders := OrderedCollection new.
	ladders add: Ladder new.
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1  ]! !
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:33:55'!
test01FloorMustHaveAMapALevelNumberAListOfLaddersAndOfSlides

	| floor ladders |
	
	ladders := OrderedCollection new.
	ladders add: Ladder new.
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1  ]! !

!methodRemoval: RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAndLadders stamp: 'MY 7/4/2022 18:33:55'!
test01FloorMustHaveAMapALevelNumberAndLadders

	| floor ladders |
	
	ladders := OrderedCollection new.
	ladders add: Ladder new.
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1  ]!
!RectangularFloorTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:34:33' prior: 50576851!
test01FloorMustHaveAMapALevelNumberAListOfLaddersAndOfSlides

	| floor ladders slides |
	
	ladders := OrderedCollection new.
	ladders add: Ladder new.
	slides := OrderedCollection new.
	floor := RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders andSlides: slides.
	
	
	^self assert: [floor map height = 5.
		floor map width = 4.
		floor level = 1.
		floor ladders size = 1.
		floor slides size = 0 ]! !

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAListOfLaddersAndOfSlides stamp: 'MY 7/4/2022 18:34:35'!
ERROR!

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAListOfLaddersAndOfSlides stamp: 'MY 7/4/2022 18:34:38'!
ERROR!
!RectangularFloor class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:34:42'!
level: aSmallInteger ofHeight: aSmallInteger2 andWidth: aSmallInteger3 withLadders: anOrderedCollection andSlides: anOrderedCollection5 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeLevel: aSmallInteger ofHeight: aSmallInteger2 andWidth: aSmallInteger3 withLadders: anOrderedCollection andSlides: anOrderedCollection5 ! !
!RectangularFloor class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:35:16' prior: 50576904!
level: aNumber ofHeight: aHeight andWidth: aWidth withLadders: listOfLadders andSlides: listOfSlides
	
	^self new level: aNumber ofHeight: (aHeight+1) andWidth: (aWidth+1) withLadders: listOfLadders andSlides: listOfSlides . ! !

!methodRemoval: RectangularFloor class #level:ofHeight:andWidth:withLadders: stamp: 'MY 7/4/2022 18:35:19'!
level: aNumber ofHeight: aHeight andWidth: aWidth withLadders: listOfLadders 
	
	^self new level: aNumber ofHeight: (aHeight+1) andWidth: (aWidth+1) withLadders: listOfLadders. !
!RectangularFloor methodsFor: 'initialize' stamp: 'MY 7/4/2022 18:35:45'!
level: aNumber ofHeight: aHeight andWidth: aWidth withLadders: listOfLadders andSlides: listOfSlides
	
	map := Rectangle origin: 1@aHeight corner: aWidth@1.
	level := aNumber.
	ladders := listOfLadders.
	slides := listOfSlides .! !
!RectangularFloor methodsFor: 'initialize' stamp: 'MY 7/4/2022 18:35:46' prior: 50576939!
level: aNumber ofHeight: aHeight andWidth: aWidth withLadders: listOfLadders andSlides: listOfSlides
	
	map := Rectangle origin: 1@aHeight corner: aWidth@1.
	level := aNumber.
	ladders := listOfLadders.
	slides := listOfSlides.! !

!methodRemoval: RectangularFloor #level:ofHeight:andWidth:withLadders: stamp: 'MY 7/4/2022 18:35:48'!
level: aNumber ofHeight: aHeight andWidth: aWidth withLadders: listOfLadders
	
	map := Rectangle origin: 1@aHeight corner: aWidth@1.
	level := aNumber.
	ladders := listOfLadders!
!RectangularFloor methodsFor: 'accessing' stamp: 'MY 7/4/2022 18:35:57'!
slides
	
	^slides.! !

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAListOfLaddersAndOfSlides stamp: 'MY 7/4/2022 18:36:00'!
PASSED!

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAListOfLaddersAndOfSlides stamp: 'MY 7/4/2022 18:36:00'!
PASSED!

TestCase subclass: #SlideTest
	instanceVariableNames: 'origin destination'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #SlideTest category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:36:26'!
TestCase subclass: #SlideTest
	instanceVariableNames: 'origin destination'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!SlideTest methodsFor: 'no messages' stamp: 'MY 7/4/2022 18:38:18'!
test01SlideOriginLevelShouldBeHigherThanDestination

	
	
	"slide := Slide fromLevel: 1 point: 1@2 toLevel: 2 point: 2@1.
	
	self should: []
	raise: "! !

----End fileIn of C:\Users\Maxi\Desktop\Facultad\Inge1\cuisNuevo\windows64\ISW1-2021-1C-2doParcial-Resolucion.st----!

!classRemoval: #RondaDeTruco stamp: 'MY 7/4/2022 18:39:13'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'cartasDeManoDisponibles cartasDePieDisponibles enfrentamientoActual'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #JuegaPie stamp: 'MY 7/4/2022 18:39:13'!
EstadoDeEnfrentamiento subclass: #JuegaPie
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #JuegaMano stamp: 'MY 7/4/2022 18:39:13'!
EstadoDeEnfrentamiento subclass: #JuegaMano
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #EnfrentamientoTerminado stamp: 'MY 7/4/2022 18:39:13'!
EstadoDeEnfrentamiento subclass: #EnfrentamientoTerminado
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #EmpiezaPie stamp: 'MY 7/4/2022 18:39:14'!
EstadoDeEnfrentamiento subclass: #EmpiezaPie
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #EmpiezaMano stamp: 'MY 7/4/2022 18:39:14'!
EstadoDeEnfrentamiento subclass: #EmpiezaMano
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #EstadoDeEnfrentamiento stamp: 'MY 7/4/2022 18:39:14'!
Object subclass: #EstadoDeEnfrentamiento
	instanceVariableNames: 'enfrentamiento'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #RondaDeTrucoTerminada stamp: 'MY 7/4/2022 18:39:14'!
EnfrentamientoDeTruco subclass: #RondaDeTrucoTerminada
	instanceVariableNames: 'anterior'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #PrimerEnfrentamientoDeTruco stamp: 'MY 7/4/2022 18:39:15'!
EnfrentamientoDeTrucoConCartas subclass: #PrimerEnfrentamientoDeTruco
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #EnfrentamientoDeTrucoPosteriorAlPrimero stamp: 'MY 7/4/2022 18:39:15'!
EnfrentamientoDeTrucoConCartas subclass: #EnfrentamientoDeTrucoPosteriorAlPrimero
	instanceVariableNames: 'anterior'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #EnfrentamientoDeTrucoConCartas stamp: 'MY 7/4/2022 18:39:15'!
EnfrentamientoDeTruco subclass: #EnfrentamientoDeTrucoConCartas
	instanceVariableNames: 'cartaDeMano cartaDePie estado'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #EnfrentamientoDeTruco stamp: 'MY 7/4/2022 18:39:15'!
Object subclass: #EnfrentamientoDeTruco
	instanceVariableNames: 'ronda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #CartaDeTruco stamp: 'MY 7/4/2022 18:39:15'!
Object subclass: #CartaDeTruco
	instanceVariableNames: 'palo numero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #TrucoTest stamp: 'MY 7/4/2022 18:39:16'!
TestCase subclass: #TrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #CartaDeTrucoTest stamp: 'MY 7/4/2022 18:39:16'!
TestCase subclass: #CartaDeTrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!
!SlideTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:42:04' prior: 50576994!
test01SlideOriginLevelShouldBeHigherThanDestination

	| slide |
	
	self 
		should: [ slide := Slide fromLevel: 1 point: 1@2 toLevel: 2 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Slide originLevelShouldBeHigherThanDestination equals: anError messageText.]! !
!SlideTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:42:15' prior: 50579160!
test01SlideOriginLevelShouldBeHigherThanDestination

	| slide |
	
	self 
		should: [ slide := Slide fromLevel: 1 point: 1@2 toLevel: 2 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Slide originLevelShouldBeHigherThanDestination equals: anError messageText.]! !

----End fileIn of C:\Users\Maxi\Desktop\Facultad\Inge1\cuisNuevo\windows64\ISW1-2021-1C-2doParcial.st----!

!classRemoval: #RondaDeTruco stamp: 'MY 7/4/2022 18:42:44'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'mano pie enfrentamiento ganadosMano ganadosPie'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #SegundoEnfrentamiento stamp: 'MY 7/4/2022 18:42:45'!
Enfrentamiento subclass: #SegundoEnfrentamiento
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #PrimerEnfrentamiento stamp: 'MY 7/4/2022 18:42:45'!
Enfrentamiento subclass: #PrimerEnfrentamiento
	instanceVariableNames: 'cartaMano'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #Enfrentamiento stamp: 'MY 7/4/2022 18:42:45'!
Object subclass: #Enfrentamiento
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #CartaDeTruco stamp: 'MY 7/4/2022 18:42:45'!
Object subclass: #CartaDeTruco
	instanceVariableNames: 'palo numero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #RondaDeTrucoTest stamp: 'MY 7/4/2022 18:42:46'!
TestCase subclass: #RondaDeTrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!

!classRemoval: #CartaDeTrucoTest stamp: 'MY 7/4/2022 18:42:46'!
TestCase subclass: #CartaDeTrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial'!
!SlideTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:43:16' prior: 50579173!
test01SlideOriginLevelShouldBeHigherThanDestination

	| slide |
	
	self 
		should: [ slide := Slide fromLevel: 1 point: 1@2 toLevel: 2 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = Slide originLevelShouldBeHigherThanDestination ]! !

!testRun: #SlideTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 18:43:20'!
ERROR!

!testRun: #SlideTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 18:43:26'!
ERROR!
!Slide class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:43:29'!
fromLevel: aSmallInteger point: aPoint toLevel: aSmallInteger3 point: aPoint4 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeFromLevel: aSmallInteger point: aPoint toLevel: aSmallInteger3 point: aPoint4 ! !
!Slide class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:44:33' prior: 50580261!
fromLevel: anOriginLevel point: originPoint toLevel: aDestinationLevel point: destinationPoint
	
	^self new fromLevel: anOriginLevel point: originPoint toLevel: aDestinationLevel point: destinationPoint ! !

!testRun: #SlideTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 18:44:35'!
ERROR!
!Slide methodsFor: 'initialize' stamp: 'MY 7/4/2022 18:44:46'!
fromLevel: aSmallInteger point: aPoint toLevel: aSmallInteger3 point: aPoint4 
	self shouldBeImplemented.! !

!classDefinition: #Slide category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:45:50'!
Object subclass: #Slide
	instanceVariableNames: 'origin destination originLevel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Slide category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:45:52'!
Object subclass: #Slide
	instanceVariableNames: 'origin destination originLevel originPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Slide category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:45:53'!
Object subclass: #Slide
	instanceVariableNames: 'origin destination originLevel originPoint destinationLevel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Slide category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:45:54'!
Object subclass: #Slide
	instanceVariableNames: 'origin destination originLevel originPoint destinationLevel destinationPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!Slide methodsFor: 'initialize' stamp: 'MY 7/4/2022 18:45:48' prior: 50580285!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	originLevel := anOriginLevel.
	originPoint := anOriginPoint.
	destinationLevel := aDestinationLevel.
	destinationPoint := aDestinationPoint.! !

!testRun: #SlideTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 18:45:55'!
FAILURE!
!Slide class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:46:46'!
originLevelShouldBeHigherThanDestination	
	
	^'The origin level of a slide must be higher than destination level'! !
!Slide class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:46:59'!
originLevelMustBeHigherThanDestination	
	
	^'The origin level of a slide must be higher than destination level'! !
!SlideTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:46:59' prior: 50580242!
test01SlideOriginLevelShouldBeHigherThanDestination

	| slide |
	
	self 
		should: [ slide := Slide fromLevel: 1 point: 1@2 toLevel: 2 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = Slide originLevelMustBeHigherThanDestination ]! !

!methodRemoval: Slide class #originLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 18:46:59'!
originLevelShouldBeHigherThanDestination	
	
	^'The origin level of a slide must be higher than destination level'!

!testRun: #SlideTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 18:47:05'!
FAILURE!
!Slide methodsFor: 'initialize' stamp: 'MY 7/4/2022 18:48:05' prior: 50580326!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	(aDestinationLevel > anOriginLevel) ifTrue: [^ self error: Slide originLevelMustBeHigherThanDestination ].
	originLevel := anOriginLevel.
	originPoint := anOriginPoint.
	destinationLevel := aDestinationLevel.
	destinationPoint := aDestinationPoint.! !

!testRun: #SlideTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 18:48:12'!
PASSED!

!testRun: #SlideTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 18:48:12'!
PASSED!
!Slide methodsFor: 'initialize' stamp: 'MY 7/4/2022 18:48:53' prior: 50580376!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validateDestinationLowerThanOrigin.
	originLevel := anOriginLevel.
	originPoint := anOriginPoint.
	destinationLevel := aDestinationLevel.
	destinationPoint := aDestinationPoint.! !
!Slide methodsFor: 'initialize' stamp: 'MY 7/4/2022 18:49:09'!
validateDestinationLowerThanOrigin

	"(aDestinationLevel > anOriginLevel) ifTrue: [^ self error: Slide originLevelMustBeHigherThanDestination ]."! !
!Slide methodsFor: 'initialize' stamp: 'MY 7/4/2022 18:49:34' prior: 50580397!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validateDestination: aDestinationLevel LowerThanOrigin: anOriginLevel .
	originLevel := anOriginLevel.
	originPoint := anOriginPoint.
	destinationLevel := aDestinationLevel.
	destinationPoint := aDestinationPoint.! !
!Slide methodsFor: 'initialize' stamp: 'MY 7/4/2022 18:49:40' prior: 50580416!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validateDestination: aDestinationLevel LowerThanOrigin: anOriginLevel.
	originLevel := anOriginLevel.
	originPoint := anOriginPoint.
	destinationLevel := aDestinationLevel.
	destinationPoint := aDestinationPoint.! !
!Slide methodsFor: 'initialize' stamp: 'MY 7/4/2022 18:49:53'!
validateDestination: aDestinationLevel LowerThanOrigin: anOriginLevel

	(aDestinationLevel > anOriginLevel) ifTrue: [^ self error: Slide originLevelMustBeHigherThanDestination ].! !

!methodRemoval: Slide #validateDestinationLowerThanOrigin stamp: 'MY 7/4/2022 18:49:56'!
validateDestinationLowerThanOrigin

	"(aDestinationLevel > anOriginLevel) ifTrue: [^ self error: Slide originLevelMustBeHigherThanDestination ]."!

!testRun: #SlideTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 18:50:00'!
PASSED!

!testRun: #SlideTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 18:50:00'!
PASSED!
!SlideTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:50:05' prior: 50580354!
test01SlideOriginLevelShouldBeHigherThanDestination

	| slide |
	
	self  should: [ slide := Slide fromLevel: 1 point: 1@2 toLevel: 2 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = Slide originLevelMustBeHigherThanDestination ]! !
!SlideTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:50:15' prior: 50580466!
test01SlideOriginLevelShouldBeHigherThanDestination

	| slide |
	
	self  should: [ slide := Slide fromLevel: 1 point: 1@2 toLevel: 2 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = Slide originLevelMustBeHigherThanDestination ]! !

TestCase subclass: #LadderTest
	instanceVariableNames: 'origin destination'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #LadderTest category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:50:30'!
TestCase subclass: #LadderTest
	instanceVariableNames: 'origin destination'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!LadderTest methodsFor: 'nil' stamp: 'MY 7/4/2022 18:51:29'!
test01SlideDestinationLevelShouldBeHigherThanOrigin

	| ladder |
	
	self  should: [ ladder := Ladder fromLevel: 2 point: 1@2 toLevel: 1 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = Ladder destinationLevelMustBeHigherThanOrigin ]! !
!LadderTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:51:45'!
test01LadderDestinationLevelShouldBeHigherThanOrigin

	| ladder |
	
	self  should: [ ladder := Ladder fromLevel: 2 point: 1@2 toLevel: 1 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = Ladder destinationLevelMustBeHigherThanOrigin ]! !

!methodRemoval: LadderTest #test01SlideDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 18:51:45'!
test01SlideDestinationLevelShouldBeHigherThanOrigin

	| ladder |
	
	self  should: [ ladder := Ladder fromLevel: 2 point: 1@2 toLevel: 1 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = Ladder destinationLevelMustBeHigherThanOrigin ]!
!SlideTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:52:01'!
test02LadderDestinationLevelShouldBeHigherThanOrigin

	| ladder |
	
	self  should: [ ladder := Ladder fromLevel: 2 point: 1@2 toLevel: 1 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = Ladder destinationLevelMustBeHigherThanOrigin ]! !

!classRenamed: #SlideTest as: #ShortcutTest stamp: 'MY 7/4/2022 18:52:15'!
Smalltalk renameClassNamed: #SlideTest as: #ShortcutTest!

!classRenamed: #ShortcutTest as: #SlideTest stamp: 'MY 7/4/2022 18:54:30'!
Smalltalk renameClassNamed: #ShortcutTest as: #SlideTest!

!methodRemoval: SlideTest #test02LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 18:54:32'!
test02LadderDestinationLevelShouldBeHigherThanOrigin

	| ladder |
	
	self  should: [ ladder := Ladder fromLevel: 2 point: 1@2 toLevel: 1 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = Ladder destinationLevelMustBeHigherThanOrigin ]!

!testRun: #LadderTest #test01LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 18:54:38'!
ERROR!
!Ladder class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:54:44'!
fromLevel: aSmallInteger point: aPoint toLevel: aSmallInteger3 point: aPoint4 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeFromLevel: aSmallInteger point: aPoint toLevel: aSmallInteger3 point: aPoint4 ! !
!Ladder class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:54:51' prior: 50580577!
fromLevel: aSmallInteger point: aPoint toLevel: aSmallInteger3 point: aPoint4 

	^self new initializeFromLevel: aSmallInteger point: aPoint toLevel: aSmallInteger3 point: aPoint4 ! !

!testRun: #LadderTest #test01LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 18:54:54'!
ERROR!
!Ladder class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 18:55:23' prior: 50580589!
fromLevel: anOriginLevel point: originPoint toLevel: aDestinationLevel point: destinationPoint
	
	^self new fromLevel: anOriginLevel point: originPoint toLevel: aDestinationLevel point: destinationPoint ! !

!classDefinition: #Ladder category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:55:46'!
Object subclass: #Ladder
	instanceVariableNames: 'origin destination originLevel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Ladder category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:55:47'!
Object subclass: #Ladder
	instanceVariableNames: 'origin destination originLevel originPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Ladder category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:55:48'!
Object subclass: #Ladder
	instanceVariableNames: 'origin destination originLevel originPoint destinationLevel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Ladder category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:55:49'!
Object subclass: #Ladder
	instanceVariableNames: 'origin destination originLevel originPoint destinationLevel destinationPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!Ladder methodsFor: 'no messages' stamp: 'MY 7/4/2022 18:55:45'!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validateDestination: aDestinationLevel LowerThanOrigin: anOriginLevel.
	originLevel := anOriginLevel.
	originPoint := anOriginPoint.
	destinationLevel := aDestinationLevel.
	destinationPoint := aDestinationPoint.! !
!Ladder methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:56:28' prior: 50580646!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validateOrigin: anOriginLevel LowerThanDestination: aDestinationLevel .
	originLevel := anOriginLevel.
	originPoint := anOriginPoint.
	destinationLevel := aDestinationLevel.
	destinationPoint := aDestinationPoint.! !
!Ladder methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 18:57:26'!
validateOrigin: anOriginLevel LowerThanDestination: aDestinationLevel

	(anOriginLevel > aDestinationLevel ) ifTrue: [^ self error: Slide originLevelMustBeHigherThanDestination ].! !

!testRun: #LadderTest #test01LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 18:57:30'!
ERROR!
!Ladder class methodsFor: 'error' stamp: 'MY 7/4/2022 18:57:39'!
destinationLevelMustBeHigherThanOrigin
	self shouldBeImplemented.! !

!testRun: #LadderTest #test01LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 18:57:41'!
ERROR!
!Ladder class methodsFor: 'error' stamp: 'MY 7/4/2022 18:58:26' prior: 50580684!
destinationLevelMustBeHigherThanOrigin
	
	^'The destination level of a slide must be higher than origin level'! !

!testRun: #LadderTest #test01LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 18:58:31'!
PASSED!

!testRun: #LadderTest #test01LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 18:58:31'!
PASSED!

Object subclass: #Shortcut
	instanceVariableNames: 'origin destination originLevel originPoint destinationLevel destinationPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Shortcut category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:58:52'!
Object subclass: #Shortcut
	instanceVariableNames: 'origin destination originLevel originPoint destinationLevel destinationPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

Shortcut subclass: #Slide
	instanceVariableNames: 'origin destination originLevel originPoint destinationLevel destinationPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

Object subclass: #Shortcut
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Shortcut category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:59:12'!
Object subclass: #Shortcut
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

Shortcut subclass: #Slide
	instanceVariableNames: 'origin destination originLevel originPoint destinationLevel destinationPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Slide category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:59:17'!
Shortcut subclass: #Slide
	instanceVariableNames: 'origin destination originLevel originPoint destinationLevel destinationPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

Shortcut subclass: #Ladder
	instanceVariableNames: 'origin destination originLevel originPoint destinationLevel destinationPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Ladder category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:59:23'!
Shortcut subclass: #Ladder
	instanceVariableNames: 'origin destination originLevel originPoint destinationLevel destinationPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

Object subclass: #Shortcut
	instanceVariableNames: 'origin destination originLevel originPoint destinationLevel destinationPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

Shortcut subclass: #Ladder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Ladder category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:59:38'!
Shortcut subclass: #Ladder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

Shortcut subclass: #Slide
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Slide category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:59:44'!
Shortcut subclass: #Slide
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

Object subclass: #Shortcut
	instanceVariableNames: 'origin destination originLevel originPoint destinationLevel destinationPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Shortcut category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 18:59:48'!
Object subclass: #Shortcut
	instanceVariableNames: 'origin destination originLevel originPoint destinationLevel destinationPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!testRun: #SlideTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 18:59:54'!
PASSED!

!testRun: #LadderTest #test01LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 18:59:59'!
PASSED!

!classRenamed: #SlideTest as: #ShortcutTest stamp: 'MY 7/4/2022 19:00:13'!
Smalltalk renameClassNamed: #SlideTest as: #ShortcutTest!
!ShortcutTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:00:24'!
test02LadderDestinationLevelShouldBeHigherThanOrigin

	| ladder |
	
	self  should: [ ladder := Ladder fromLevel: 2 point: 1@2 toLevel: 1 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = Ladder destinationLevelMustBeHigherThanOrigin ]! !

!testRun: #ShortcutTest #test02LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 19:00:27'!
PASSED!

!testRun: #ShortcutTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 19:00:27'!
PASSED!

!testRun: #ShortcutTest #test02LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 19:00:27'!
PASSED!

!classRemoval: #LadderTest stamp: 'MY 7/4/2022 19:00:30'!
TestCase subclass: #LadderTest
	instanceVariableNames: 'origin destination'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!Shortcut class methodsFor: 'no messages' stamp: 'MY 7/4/2022 19:01:05'!
fromLevel: anOriginLevel point: originPoint toLevel: aDestinationLevel point: destinationPoint
	
	^self new fromLevel: anOriginLevel point: originPoint toLevel: aDestinationLevel point: destinationPoint ! !

!methodRemoval: Ladder class #fromLevel:point:toLevel:point: stamp: 'MY 7/4/2022 19:01:10'!
fromLevel: anOriginLevel point: originPoint toLevel: aDestinationLevel point: destinationPoint
	
	^self new fromLevel: anOriginLevel point: originPoint toLevel: aDestinationLevel point: destinationPoint !

!methodRemoval: Slide class #fromLevel:point:toLevel:point: stamp: 'MY 7/4/2022 19:01:14'!
fromLevel: anOriginLevel point: originPoint toLevel: aDestinationLevel point: destinationPoint
	
	^self new fromLevel: anOriginLevel point: originPoint toLevel: aDestinationLevel point: destinationPoint !

!testRun: #ShortcutTest #test02LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 19:01:19'!
PASSED!

!testRun: #ShortcutTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 19:01:20'!
PASSED!
!Slide methodsFor: 'initialize' stamp: 'MY 7/4/2022 19:02:43' prior: 50580429!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validateDestination: aDestinationLevel LowerThanOrigin: anOriginLevel.
	super fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint.
! !
!Slide methodsFor: 'initialize' stamp: 'MY 7/4/2022 19:02:44' prior: 50580897!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validateDestination: aDestinationLevel LowerThanOrigin: anOriginLevel.
	super fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint.! !
!Shortcut methodsFor: 'no messages' stamp: 'MY 7/4/2022 19:03:03'!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 

	originLevel := anOriginLevel.
	originPoint := anOriginPoint.
	destinationLevel := aDestinationLevel.
	destinationPoint := aDestinationPoint.
	! !
!Shortcut methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:03:05' prior: 50580921!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 

	originLevel := anOriginLevel.
	originPoint := anOriginPoint.
	destinationLevel := aDestinationLevel.
	destinationPoint := aDestinationPoint.! !
!Ladder methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:03:17' prior: 50580659 overrides: 50580932!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validateOrigin: anOriginLevel LowerThanDestination: aDestinationLevel .
	super fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint.! !

!testRun: #ShortcutTest #test02LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 19:03:22'!
PASSED!

!testRun: #ShortcutTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 19:03:22'!
PASSED!

!testRun: #ShortcutTest #test02LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 19:03:22'!
PASSED!
!Slide methodsFor: 'initialize' stamp: 'MY 7/4/2022 19:04:32'!
validate: aDestinationLevel LowerThanOrigin: anOriginLevel

	(aDestinationLevel > anOriginLevel) ifTrue: [^ self error: Slide originLevelMustBeHigherThanDestination ].! !

!testRun: #LaddersAndSlidesTest #test01 stamp: 'MY 7/4/2022 19:04:32'!
PASSED!

!testRun: #LaddersAndSlidesTest #test01FloorMustHaveALadder stamp: 'MY 7/4/2022 19:04:32'!
PASSED!

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAListOfLaddersAndOfSlides stamp: 'MY 7/4/2022 19:04:32'!
PASSED!

!testRun: #ShortcutTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 19:04:32'!
PASSED!

!testRun: #ShortcutTest #test02LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 19:04:32'!
PASSED!
!Shortcut methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:05:34'!
validate: aLevel LowerThan: anotherLevel orThrow: errorMessage

	(aLevel > anotherLevel) ifTrue: [^ self error: errorMessage ].! !
!Ladder methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:06:25' prior: 50580944 overrides: 50580932!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validate: anOriginLevel LowerThan: aDestinationLevel orError: Slide originLevelMustBeHigherThanDestination.
	super fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint.! !
!Ladder methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:06:37' prior: 50580999 overrides: 50580932!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validate: anOriginLevel LowerThan: aDestinationLevel orThrow: Slide originLevelMustBeHigherThanDestination.
	super fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint.! !
!Slide methodsFor: 'initialize' stamp: 'MY 7/4/2022 19:07:04' prior: 50580909 overrides: 50580932!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validate: aDestinationLevel LowerThan: anOriginLevel orThrow: Ladder destinationLevelMustBeHigherThanOrigin .
	super fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint.! !

!methodRemoval: Slide #validate:LowerThanOrigin: stamp: 'MY 7/4/2022 19:07:07'!
validate: aDestinationLevel LowerThanOrigin: anOriginLevel

	(aDestinationLevel > anOriginLevel) ifTrue: [^ self error: Slide originLevelMustBeHigherThanDestination ].!

!methodRemoval: Slide #validateDestination:LowerThanOrigin: stamp: 'MY 7/4/2022 19:07:36'!
validateDestination: aDestinationLevel LowerThanOrigin: anOriginLevel

	(aDestinationLevel > anOriginLevel) ifTrue: [^ self error: Slide originLevelMustBeHigherThanDestination ].!

!methodRemoval: Ladder #validateOrigin:LowerThanDestination: stamp: 'MY 7/4/2022 19:07:43'!
validateOrigin: anOriginLevel LowerThanDestination: aDestinationLevel

	(anOriginLevel > aDestinationLevel ) ifTrue: [^ self error: Slide originLevelMustBeHigherThanDestination ].!
!Slide methodsFor: 'initialize' stamp: 'MY 7/4/2022 19:08:01' prior: 50581027 overrides: 50580932!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validate: aDestinationLevel LowerThan: anOriginLevel orThrow: Slide originLevelMustBeHigherThanDestination.
	super fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint.! !
!Ladder methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:08:15' prior: 50581013 overrides: 50580932!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validate: anOriginLevel LowerThan: aDestinationLevel orThrow: Ladder destinationLevelMustBeHigherThanOrigin.
	super fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint.! !

!testRun: #ShortcutTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 19:08:19'!
PASSED!

!testRun: #ShortcutTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 19:08:20'!
PASSED!

!testRun: #ShortcutTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 19:08:20'!
PASSED!

!testRun: #ShortcutTest #test02LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 19:08:20'!
PASSED!

!methodRemoval: LaddersAndSlidesTest #test01FloorMustHaveALadder stamp: 'MY 7/4/2022 19:10:21'!
test01FloorMustHaveALadder!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:12:15'!
test01GameMustStartWithFloorsBeginningAndEnd

	| firstFloor |
	
	firstFloor := self sqrtFloor.
	
	^self assert: [].! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:12:21' prior: 50581112!
test01GameMustStartWithFloorsBeginningAndEnd

	| firstFloor |
	
	firstFloor := self firstFloor.
	
	^self assert: [].! !

!methodRemoval: LaddersAndSlidesTest #test01 stamp: 'MY 7/4/2022 19:12:26'!
test01!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:12:53'!
firstFloor

	| ladders slides |
	
	ladders := OrderedCollection new.
	ladders add: Ladder new.
	slides := OrderedCollection new.
	^ RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders andSlides: slides.! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:13:59' prior: 50581129!
firstFloor

	| ladders slides |
	
	ladders := OrderedCollection new.
	ladders add: (Ladder fromLevel: 1 point: 2@3 toLevel: 2 point: 2@2).
.
	slides := OrderedCollection new.
	^ RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders andSlides: slides.! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:14:14' prior: 50581140!
firstFloor

	| ladders slides |
	
	ladders := OrderedCollection new.
	ladders add: (Ladder fromLevel: 1 point: 2@3 toLevel: 2 point: 2@2).

	slides := OrderedCollection new.
	^ RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: ladders andSlides: slides.! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:15:39'!
secondFloor

	| shortcuts |
	
	shortcuts := OrderedCollection new.
	
	^ RectangularFloor level: 2 ofHeight: 5 andWidth: 4 withLadders: shortcuts andSlides: shortcuts.! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:15:56' prior: 50581119!
test01GameMustStartWithFloorsBeginningAndEnd

	| firstFloor secondFloor |
	
	firstFloor := self firstFloor.
	secondFloor := self secondFloor.
	
	^self assert: [].! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:17:21'!
test02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor

	| firstFloor secondFloor |
	
	firstFloor := self firstFloor.
	secondFloor := self secondFloor.
	
	^self assert: [].! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:20:08' prior: 50581181!
test02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor

	| firstFloor secondFloor |
	
	firstFloor := self firstFloor.
	secondFloor := self secondFloor.
	
	^self assert: [].
	
	"self  should: [ slide := Slide fromLevel: 1 point: 1@2 toLevel: 2 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = Slide originLevelMustBeHigherThanDestination ]"! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:27:13'!
test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	
	
	"game movePlayer: aPlayer places: 1
	game movePlayer: aPlayer places: 6
	game movePlayer: aPlayer places: 12"
	! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:27:17' prior: 50581206!
test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	"game movePlayer: aPlayer places: 1
	game movePlayer: aPlayer places: 6
	game movePlayer: aPlayer places: 12"
	! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:28:47'!
test01PlayersMustStartOnBeginning

	| firstFloor secondFloor |
	
	firstFloor := self firstFloor.
	secondFloor := self secondFloor.
	
	^self assert: [].! !

!methodRemoval: LaddersAndSlidesTest #test01GameMustStartWithFloorsBeginningAndEnd stamp: 'MY 7/4/2022 19:28:47'!
test01GameMustStartWithFloorsBeginningAndEnd

	| firstFloor secondFloor |
	
	firstFloor := self firstFloor.
	secondFloor := self secondFloor.
	
	^self assert: [].!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:29:32' prior: 50581225!
test01PlayersMustStartOnBeginning "mínimo 2, no hay máx"

	| firstFloor secondFloor |
	
	firstFloor := self firstFloor.
	secondFloor := self secondFloor.
	
	^self assert: [].! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:32:28'!
xtest02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor

	| firstFloor secondFloor |
	
	firstFloor := self firstFloor.
	secondFloor := self secondFloor.
	
	^self assert: [].
	
	"self  should: [ slide := Slide fromLevel: 1 point: 1@2 toLevel: 2 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = Slide originLevelMustBeHigherThanDestination ]"! !

!methodRemoval: LaddersAndSlidesTest #test02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor stamp: 'MY 7/4/2022 19:32:28'!
test02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor

	| firstFloor secondFloor |
	
	firstFloor := self firstFloor.
	secondFloor := self secondFloor.
	
	^self assert: [].
	
	"self  should: [ slide := Slide fromLevel: 1 point: 1@2 toLevel: 2 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = Slide originLevelMustBeHigherThanDestination ]"!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:32:31'!
xtest03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	"game movePlayer: aPlayer places: 1
	game movePlayer: aPlayer places: 6
	game movePlayer: aPlayer places: 12"
	! !

!methodRemoval: LaddersAndSlidesTest #test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 19:32:31'!
test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	"game movePlayer: aPlayer places: 1
	game movePlayer: aPlayer places: 6
	game movePlayer: aPlayer places: 12"
	!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:34:41' prior: 50581242!
test01PlayersMustStartOnBeginning "mínimo 2, no hay máx"

	| firstFloor secondFloor game floors |
	
	firstFloor := self firstFloor.
	secondFloor := self secondFloor.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	game := LaddersAndSlides withFloors: floors 
	
	^self assert: [].! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:34:45' prior: 50581303!
test01PlayersMustStartOnBeginning "mínimo 2, no hay máx"

	| firstFloor secondFloor game floors |
	
	firstFloor := self firstFloor.
	secondFloor := self secondFloor.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	game := LaddersAndSlides withFloors: floors .
	
	^self assert: [].! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:36:46' prior: 50581317!
test01PlayersMustStartOnBeginning "mínimo 2, no hay máx"

	| firstFloor secondFloor game floors |
	
	firstFloor := self firstFloor.
	secondFloor := self secondFloor.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 .
	
	game players do:[:aPlayer | 
		self assert: [aPlayer = 1@1]].! !

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 19:36:53'!
ERROR!
!LaddersAndSlides class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 19:37:38'!
withFloors: anOrderedCollection beginningFloor: aSmallInteger point: aPoint endingFloor: aSmallInteger4 point: aPoint5 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeWithFloors: anOrderedCollection beginningFloor: aSmallInteger point: aPoint endingFloor: aSmallInteger4 point: aPoint5 ! !
!LaddersAndSlides class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 19:38:59' prior: 50581351!
withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint 
	
	^self new withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint ! !

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 19:39:01'!
ERROR!
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 19:39:10'!
withFloors: anOrderedCollection beginningFloor: aSmallInteger point: aPoint endingFloor: aSmallInteger4 point: aPoint5 
	self shouldBeImplemented.! !

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 19:39:13'!
ERROR!

!classDefinition: #LaddersAndSlides category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 19:40:36'!
Object subclass: #LaddersAndSlides
	instanceVariableNames: 'floors'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #LaddersAndSlides category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 19:40:38'!
Object subclass: #LaddersAndSlides
	instanceVariableNames: 'floors beginningFloor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #LaddersAndSlides category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 19:40:39'!
Object subclass: #LaddersAndSlides
	instanceVariableNames: 'floors beginningFloor endingFloor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #LaddersAndSlides category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 19:40:45'!
Object subclass: #LaddersAndSlides
	instanceVariableNames: 'floors beginningFloor endingFloor begin'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #LaddersAndSlides category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 19:40:46'!
Object subclass: #LaddersAndSlides
	instanceVariableNames: 'floors beginningFloor endingFloor begin end'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 19:40:43' prior: 50581380!
withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint 

	floors := aListOfFloors.
	beginningFloor := aBeginningFloor.
	endingFloor := anEndingFloor.
	begin := beginPoint.
	end := endPoint.! !

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 19:40:56'!
ERROR!
!LaddersAndSlides methodsFor: 'accessing' stamp: 'MY 7/4/2022 19:41:03'!
players
	self shouldBeImplemented.! !

!classDefinition: #LaddersAndSlides category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 19:41:10'!
Object subclass: #LaddersAndSlides
	instanceVariableNames: 'floors beginningFloor endingFloor begin end players'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!LaddersAndSlides methodsFor: 'accessing' stamp: 'MY 7/4/2022 19:41:09' prior: 50581449!
players
	
	^ players.! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:41:26' prior: 50581331!
test01PlayersMustStartOnBeginning "mínimo 2, no hay máx"

	| firstFloor secondFloor game floors |
	
	firstFloor := self firstFloor.
	secondFloor := self secondFloor.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 andPlayers: 2.
	
	game players do:[:aPlayer | 
		self assert: [aPlayer = 1@1]].! !
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 19:41:50'!
withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint andPlayers: aNumberOfPlayers

	floors := aListOfFloors.
	players := aNumberOfPlayers.
	beginningFloor := aBeginningFloor.
	endingFloor := anEndingFloor.
	begin := beginPoint.
	end := endPoint.! !

!methodRemoval: LaddersAndSlides #withFloors:beginningFloor:point:endingFloor:point: stamp: 'MY 7/4/2022 19:41:53'!
withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint 

	floors := aListOfFloors.
	beginningFloor := aBeginningFloor.
	endingFloor := anEndingFloor.
	begin := beginPoint.
	end := endPoint.!
!LaddersAndSlides class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 19:42:06'!
withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint andPlayers: aNumberOfPlayers
	
	^self new withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint andPlayers: aNumberOfPlayers.! !

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 19:42:12'!
ERROR!
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 19:42:38' prior: 50581483!
withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint andPlayers: aNumberOfPlayers

	floors := aListOfFloors.
	beginningFloor := aBeginningFloor.
	endingFloor := anEndingFloor.
	begin := beginPoint.
	end := endPoint.
	players := aNumberOfPlayers.! !
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 19:45:50' prior: 50581524!
withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint andPlayers: aNumberOfPlayers

	floors := aListOfFloors.
	beginningFloor := aBeginningFloor.
	endingFloor := anEndingFloor.
	begin := beginPoint.
	end := endPoint.
	players := aNumberOfPlayers ! !
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 19:46:49' prior: 50581537!
withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint andPlayers: aNumberOfPlayers

	floors := aListOfFloors.
	beginningFloor := aBeginningFloor.
	endingFloor := anEndingFloor.
	begin := beginPoint.
	end := endPoint.
	players := OrderedCollection new.
	players := aNumberOfPlayers timesRepeat: [ players add: beginPoint ].! !

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 19:46:55'!
ERROR!
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 19:47:16' prior: 50581550!
withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint andPlayers: aNumberOfPlayers

	floors := aListOfFloors.
	beginningFloor := aBeginningFloor.
	endingFloor := anEndingFloor.
	begin := beginPoint.
	end := endPoint.
	players := OrderedCollection new.
	aNumberOfPlayers timesRepeat: [ players add: beginPoint ].! !

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 19:47:31'!
ERROR!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:48:18' prior: 50581467!
test01PlayersMustStartOnBeginning "mínimo 2, no hay máx"

	| firstFloor secondFloor game floors |
	
	firstFloor := self firstFloor.
	secondFloor := self secondFloor.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 andPlayers: 2.
	
	game players do:[:aPlayer | 
		self assert: [aPlayer = (1@1)]].! !

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 19:48:19'!
PASSED!

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 19:48:20'!
PASSED!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:50:17'!
xtest04IfPlayerMovedToShortcutShouldMoveToDestinationOfShortcut

	! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:51:17'!
xtest05IfPlayerMovedToBeginningOfShortcutConnectionsShouldMoveToLastShortcutDestination

	! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:52:20'!
xtest06IfPlayerMovedToEndGameShouldEnd

	! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:52:34'!
xtest05IfPlayerMovedToShortcutShouldMoveToDestinationOfShortcut

	! !

!methodRemoval: LaddersAndSlidesTest #xtest04IfPlayerMovedToShortcutShouldMoveToDestinationOfShortcut stamp: 'MY 7/4/2022 19:52:34'!
xtest04IfPlayerMovedToShortcutShouldMoveToDestinationOfShortcut

	!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:52:51'!
xtest06IfPlayerMovedToBeginningOfShortcutConnectionsShouldMoveToLastShortcutDestination

	! !

!methodRemoval: LaddersAndSlidesTest #xtest05IfPlayerMovedToBeginningOfShortcutConnectionsShouldMoveToLastShortcutDestination stamp: 'MY 7/4/2022 19:52:51'!
xtest05IfPlayerMovedToBeginningOfShortcutConnectionsShouldMoveToLastShortcutDestination

	!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:52:58'!
xtest07IfPlayerMovedToEndGameShouldEnd

	! !

!methodRemoval: LaddersAndSlidesTest #xtest06IfPlayerMovedToEndGameShouldEnd stamp: 'MY 7/4/2022 19:52:58'!
xtest06IfPlayerMovedToEndGameShouldEnd

	!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:53:37'!
xtest04IfPlayerMovedMoreThanMapBorderItShouldLandAtBorder

	! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:56:34'!
firstFloorWithoutLadder

	| shortcut |
	
	shortcut := OrderedCollection new.

	^ RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: shortcut andSlides: shortcut.! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:56:57' prior: 50581667!
firstFloorWithoutLadder

	| shortcuts |
	
	shortcuts := OrderedCollection new.

	^ RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: shortcuts andSlides: shortcuts.! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:57:29'!
floorWithoutShortcuts

	| shortcuts |
	
	shortcuts := OrderedCollection new.
	
	^ RectangularFloor level: 2 ofHeight: 5 andWidth: 4 withLadders: shortcuts andSlides: shortcuts.! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:57:29' prior: 50581588!
test01PlayersMustStartOnBeginning "mínimo 2, no hay máx"

	| firstFloor secondFloor game floors |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcuts.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 andPlayers: 2.
	
	game players do:[:aPlayer | 
		self assert: [aPlayer = (1@1)]].! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:57:29' prior: 50581251!
xtest02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor

	| firstFloor secondFloor |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcuts.
	
	^self assert: [].
	
	"self  should: [ slide := Slide fromLevel: 1 point: 1@2 toLevel: 2 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = Slide originLevelMustBeHigherThanDestination ]"! !

!methodRemoval: LaddersAndSlidesTest #secondFloor stamp: 'MY 7/4/2022 19:57:29'!
secondFloor

	| shortcuts |
	
	shortcuts := OrderedCollection new.
	
	^ RectangularFloor level: 2 ofHeight: 5 andWidth: 4 withLadders: shortcuts andSlides: shortcuts.!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:57:46'!
floorWithoutShortcutsLevel: aLevel

	| shortcuts |
	
	shortcuts := OrderedCollection new.
	
	^ RectangularFloor level: aLevel ofHeight: 5 andWidth: 4 withLadders: shortcuts andSlides: shortcuts.! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:57:56' prior: 50581694!
test01PlayersMustStartOnBeginning "mínimo 2, no hay máx"

	| firstFloor secondFloor game floors |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 andPlayers: 2.
	
	game players do:[:aPlayer | 
		self assert: [aPlayer = (1@1)]].! !

!methodRemoval: LaddersAndSlidesTest #floorWithoutShortcuts stamp: 'MY 7/4/2022 19:58:00'!
floorWithoutShortcuts

	| shortcuts |
	
	shortcuts := OrderedCollection new.
	
	^ RectangularFloor level: 2 ofHeight: 5 andWidth: 4 withLadders: shortcuts andSlides: shortcuts.!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:58:41' prior: 50581712!
xtest02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor

	| firstFloor secondFloor thirdFloor|
	
	firstFloor := self firstFloor .
	secondFloor := self floorWithoutShortcutsLevel: 2.
	thirdFloor := self floorWithoutShortcutsLevel: 3.
	
	^self assert: [].
	
	"self  should: [ slide := Slide fromLevel: 1 point: 1@2 toLevel: 2 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = Slide originLevelMustBeHigherThanDestination ]"! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 19:58:46' prior: 50581772!
xtest02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor

	| firstFloor secondFloor thirdFloor |
	
	firstFloor := self firstFloor .
	secondFloor := self floorWithoutShortcutsLevel: 2.
	thirdFloor := self floorWithoutShortcutsLevel: 3.
	
	^self assert: [].
	
	"self  should: [ slide := Slide fromLevel: 1 point: 1@2 toLevel: 2 point: 2@1 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = Slide originLevelMustBeHigherThanDestination ]"! !

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 19:58:55'!
PASSED!

!methodRemoval: LaddersAndSlidesTest #firstFloorWithoutLadder stamp: 'MY 7/4/2022 19:59:01'!
firstFloorWithoutLadder

	| shortcuts |
	
	shortcuts := OrderedCollection new.

	^ RectangularFloor level: 1 ofHeight: 5 andWidth: 4 withLadders: shortcuts andSlides: shortcuts.!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:00:15' prior: 50581791!
xtest02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor

	| firstFloor secondFloor thirdFloor floors game |
	
	firstFloor := self firstFloor .
	secondFloor := self floorWithoutShortcutsLevel: 2.
	thirdFloor := self floorWithoutShortcutsLevel: 3.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor with: thirdFloor).
	
	^self  should: [ game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 andPlayers: 3. ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = LaddersAndSlides beginMustConnectEnd ]! !

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 20:00:19'!
PASSED!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:00:23'!
test02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor

	| firstFloor secondFloor thirdFloor floors game |
	
	firstFloor := self firstFloor .
	secondFloor := self floorWithoutShortcutsLevel: 2.
	thirdFloor := self floorWithoutShortcutsLevel: 3.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor with: thirdFloor).
	
	^self  should: [ game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 andPlayers: 3. ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = LaddersAndSlides beginMustConnectEnd ]! !

!methodRemoval: LaddersAndSlidesTest #xtest02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor stamp: 'MY 7/4/2022 20:00:23'!
xtest02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor

	| firstFloor secondFloor thirdFloor floors game |
	
	firstFloor := self firstFloor .
	secondFloor := self floorWithoutShortcutsLevel: 2.
	thirdFloor := self floorWithoutShortcutsLevel: 3.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor with: thirdFloor).
	
	^self  should: [ game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 andPlayers: 3. ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = LaddersAndSlides beginMustConnectEnd ]!

!testRun: #LaddersAndSlidesTest #test02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor stamp: 'MY 7/4/2022 20:00:25'!
FAILURE!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:00:39' prior: 50581848!
test02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor

	| firstFloor secondFloor thirdFloor floors game |
	
	firstFloor := self firstFloor .
	secondFloor := self floorWithoutShortcutsLevel: 2.
	thirdFloor := self floorWithoutShortcutsLevel: 3.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor with: thirdFloor).
	
	^self
		should: [ game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 andPlayers: 3. ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = LaddersAndSlides beginMustConnectEnd ]! !

!methodRemoval: LaddersAndSlides class #withFloors:beginningFloor:point:endingFloor:point: stamp: 'MY 7/4/2022 20:01:16'!
withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint 
	
	^self new withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint !
!LaddersAndSlides class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 20:03:03' prior: 50581508!
withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint andPlayers: aNumberOfPlayers
	
	^self new withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint andPlayers: aNumberOfPlayers.! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:03:43' prior: 50581898!
test02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor "Se va porque enunciado dice asumir que todo ok"

	| firstFloor secondFloor thirdFloor floors game |
	
	firstFloor := self firstFloor .
	secondFloor := self floorWithoutShortcutsLevel: 2.
	thirdFloor := self floorWithoutShortcutsLevel: 3.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor with: thirdFloor).
	
	^self
		should: [ game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 andPlayers: 3. ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = LaddersAndSlides beginMustConnectEnd ]! !

!methodRemoval: LaddersAndSlidesTest #test02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor stamp: 'MY 7/4/2022 20:03:47'!
test02LevelsMustHaveAShortcutFromBeginningFloorToEndFloor "Se va porque enunciado dice asumir que todo ok"

	| firstFloor secondFloor thirdFloor floors game |
	
	firstFloor := self firstFloor .
	secondFloor := self floorWithoutShortcutsLevel: 2.
	thirdFloor := self floorWithoutShortcutsLevel: 3.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor with: thirdFloor).
	
	^self
		should: [ game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 andPlayers: 3. ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | anError messageText = LaddersAndSlides beginMustConnectEnd ]!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:03:51'!
test02MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	"game movePlayer: aPlayer places: 1
	game movePlayer: aPlayer places: 6
	game movePlayer: aPlayer places: 12"
	! !

!methodRemoval: LaddersAndSlidesTest #xtest03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 20:03:51'!
xtest03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	"game movePlayer: aPlayer places: 1
	game movePlayer: aPlayer places: 6
	game movePlayer: aPlayer places: 12"
	!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:07:46' prior: 50581995!
test02MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 6@6 endingFloor: 2 point: 4@4 andPlayers: 2.
	
	game movePlayer: 1@1 places: 1.
	self assert: (game playerPosition: 1) equals: 1@1
	game movePlayer: 1 places: 6.

	game movePlayer: 1 places: 12.
	! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:07:58' prior: 50581152!
firstFloor

	| ladders slides |
	
	ladders := OrderedCollection new.
	ladders add: (Ladder fromLevel: 1 point: 2@3 toLevel: 2 point: 2@2).

	slides := OrderedCollection new.
	^ RectangularFloor level: 1 ofHeight: 20 andWidth: 20 withLadders: ladders andSlides: slides.! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:08:39' prior: 50582015!
test02MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 6@6 endingFloor: 2 point: 4@4 andPlayers: 2.
	
	game movePlayer: 1 places: 1.
	self assert: (game playerPosition: 1) equals: 1@1
	game movePlayer: 1 places: 6.

	game movePlayer: 1 places: 12.
	! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:14:53' prior: 50582048!
test02MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 andPlayers: 2.
	
	game movePlayer: 1 places: 1@1.
	self assert: (game playerPosition: 1) equals: 2@2.
	game movePlayer: 1 places: 6@6.
	self assert: (game playerPosition: 1) equals: 2@2.
	game movePlayer: 1 places: 12@12.
	self assert: (game playerPosition: 1) equals: 8@8.
	
	! !

!testRun: #LaddersAndSlidesTest #test02MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 20:15:37'!
ERROR!

Object subclass: #Dice
	instanceVariableNames: 'origin destination'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Dice category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 20:16:53'!
Object subclass: #Dice
	instanceVariableNames: 'origin destination'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

Random between: 1 and: 5!

Number between: 1 and: 5!

12 to: 2!

(1 to: 10) atRandom!
!Dice methodsFor: 'no messages' stamp: 'MY 7/4/2022 20:20:21'!
throwDice

	^ (1 to: 12) atRandom! !

Object subclass: #Dice
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Dice category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 20:20:49'!
Object subclass: #Dice
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Dice category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 20:21:17'!
Object subclass: #Dice
	instanceVariableNames: 'faces'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!Dice methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:21:15' prior: 50582112!
throwDice

	^ (1 to: faces) atRandom! !
!Dice class methodsFor: 'nil' stamp: 'MY 7/4/2022 20:21:46'!
withFaces: aNumber

	^self new initializeWithFaces: aNumber! !
!Dice methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:22:04'!
initializeWithFaces: aNumber

	faces := aNumber.! !
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 20:22:41'!
initializeWithFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint andPlayers: aNumberOfPlayers

	floors := aListOfFloors.
	beginningFloor := aBeginningFloor.
	endingFloor := anEndingFloor.
	begin := beginPoint.
	end := endPoint.
	players := OrderedCollection new.
	aNumberOfPlayers timesRepeat: [ players add: beginPoint ].! !
!LaddersAndSlides class methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:22:41' prior: 50581933!
withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint andPlayers: aNumberOfPlayers
	
	^self new initializeWithFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint andPlayers: aNumberOfPlayers.! !

!methodRemoval: LaddersAndSlides #withFloors:beginningFloor:point:endingFloor:point:andPlayers: stamp: 'MY 7/4/2022 20:22:41'!
withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint andPlayers: aNumberOfPlayers

	floors := aListOfFloors.
	beginningFloor := aBeginningFloor.
	endingFloor := anEndingFloor.
	begin := beginPoint.
	end := endPoint.
	players := OrderedCollection new.
	aNumberOfPlayers timesRepeat: [ players add: beginPoint ].!
!RectangularFloor methodsFor: 'initialize' stamp: 'MY 7/4/2022 20:23:02'!
initializeLevel: aNumber ofHeight: aHeight andWidth: aWidth withLadders: listOfLadders andSlides: listOfSlides
	
	map := Rectangle origin: 1@aHeight corner: aWidth@1.
	level := aNumber.
	ladders := listOfLadders.
	slides := listOfSlides.! !
!RectangularFloor class methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:23:02' prior: 50576920!
level: aNumber ofHeight: aHeight andWidth: aWidth withLadders: listOfLadders andSlides: listOfSlides
	
	^self new initializeLevel: aNumber ofHeight: (aHeight+1) andWidth: (aWidth+1) withLadders: listOfLadders andSlides: listOfSlides . ! !

!methodRemoval: RectangularFloor #level:ofHeight:andWidth:withLadders:andSlides: stamp: 'MY 7/4/2022 20:23:02'!
level: aNumber ofHeight: aHeight andWidth: aWidth withLadders: listOfLadders andSlides: listOfSlides
	
	map := Rectangle origin: 1@aHeight corner: aWidth@1.
	level := aNumber.
	ladders := listOfLadders.
	slides := listOfSlides.!
!Shortcut methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:23:18'!
initializeFromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 

	originLevel := anOriginLevel.
	originPoint := anOriginPoint.
	destinationLevel := aDestinationLevel.
	destinationPoint := aDestinationPoint.! !
!Ladder methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:23:18' overrides: 50582225!
initializeFromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validate: anOriginLevel LowerThan: aDestinationLevel orThrow: Ladder destinationLevelMustBeHigherThanOrigin.
	super fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint.! !
!Slide methodsFor: 'initialize' stamp: 'MY 7/4/2022 20:23:18' overrides: 50582225!
initializeFromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validate: aDestinationLevel LowerThan: anOriginLevel orThrow: Slide originLevelMustBeHigherThanDestination.
	super fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint.! !
!Shortcut class methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:23:18' prior: 50580862!
fromLevel: anOriginLevel point: originPoint toLevel: aDestinationLevel point: destinationPoint
	
	^self new initializeFromLevel: anOriginLevel point: originPoint toLevel: aDestinationLevel point: destinationPoint ! !
!Slide methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:23:18' prior: 50581066 overrides: 50580932!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validate: aDestinationLevel LowerThan: anOriginLevel orThrow: Slide originLevelMustBeHigherThanDestination.
	super initializeFromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint.! !
!Ladder methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:23:18' prior: 50581080 overrides: 50580932!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validate: anOriginLevel LowerThan: aDestinationLevel orThrow: Ladder destinationLevelMustBeHigherThanOrigin.
	super initializeFromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint.! !
!Ladder methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:23:18' prior: 50582236 overrides: 50582225!
initializeFromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validate: anOriginLevel LowerThan: aDestinationLevel orThrow: Ladder destinationLevelMustBeHigherThanOrigin.
	super initializeFromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint.! !
!Slide methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:23:18' prior: 50582250 overrides: 50582225!
initializeFromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validate: aDestinationLevel LowerThan: anOriginLevel orThrow: Slide originLevelMustBeHigherThanDestination.
	super initializeFromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint.! !

!methodRemoval: Shortcut #fromLevel:point:toLevel:point: stamp: 'MY 7/4/2022 20:23:19'!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 

	originLevel := anOriginLevel.
	originPoint := anOriginPoint.
	destinationLevel := aDestinationLevel.
	destinationPoint := aDestinationPoint.!

!methodRemoval: Ladder #fromLevel:point:toLevel:point: stamp: 'MY 7/4/2022 20:23:19'!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validate: anOriginLevel LowerThan: aDestinationLevel orThrow: Ladder destinationLevelMustBeHigherThanOrigin.
	super initializeFromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint.!

!methodRemoval: Slide #fromLevel:point:toLevel:point: stamp: 'MY 7/4/2022 20:23:19'!
fromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint 
	
	self validate: aDestinationLevel LowerThan: anOriginLevel orThrow: Slide originLevelMustBeHigherThanDestination.
	super initializeFromLevel: anOriginLevel point: anOriginPoint toLevel: aDestinationLevel point: aDestinationPoint.!

!testRun: #ShortcutTest #test02LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 20:23:31'!
PASSED!

!testRun: #ShortcutTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 20:23:31'!
PASSED!

!testRun: #ShortcutTest #test02LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 20:23:31'!
PASSED!

!testRun: #ShortcutTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 20:23:36'!
PASSED!

!testRun: #ShortcutTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 20:23:36'!
PASSED!

!testRun: #ShortcutTest #test02LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 20:23:36'!
PASSED!

!testRun: #ShortcutTest #test02LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 20:23:40'!
PASSED!

!testRun: #ShortcutTest #test01SlideOriginLevelShouldBeHigherThanDestination stamp: 'MY 7/4/2022 20:23:40'!
PASSED!

!testRun: #ShortcutTest #test02LadderDestinationLevelShouldBeHigherThanOrigin stamp: 'MY 7/4/2022 20:23:40'!
PASSED!

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAListOfLaddersAndOfSlides stamp: 'MY 7/4/2022 20:23:43'!
PASSED!

!testRun: #RectangularFloorTest #test01FloorMustHaveAMapALevelNumberAListOfLaddersAndOfSlides stamp: 'MY 7/4/2022 20:23:43'!
PASSED!

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 20:23:49'!
PASSED!

!testRun: #LaddersAndSlidesTest #test02MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 20:23:51'!
ERROR!

!testRun: #LaddersAndSlidesTest #test02MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 20:23:51'!
ERROR!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:24:56' prior: 50581746!
test01PlayersMustStartOnBeginning "mínimo 2, no hay máx"

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	
	game players do:[:aPlayer | 
		self assert: [aPlayer = (1@1)]].! !
!LaddersAndSlides class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 20:25:12'!
withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint withDice: aDice andPlayers: aNumberOfPlayers
	
	^self new initializeWithFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint withDice: aDice andPlayers: aNumberOfPlayers.! !

!classDefinition: #LaddersAndSlides category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 20:25:27'!
Object subclass: #LaddersAndSlides
	instanceVariableNames: 'floors beginningFloor endingFloor begin end players dice'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 20:25:25'!
initializeWithFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint withDice: aDice andPlayers: aNumberOfPlayers

	floors := aListOfFloors.
	beginningFloor := aBeginningFloor.
	endingFloor := anEndingFloor.
	begin := beginPoint.
	end := endPoint.
	dice := aDice.
	players := OrderedCollection new.
	aNumberOfPlayers timesRepeat: [ players add: beginPoint ].! !

!testRun: #LaddersAndSlidesTest #test02MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 20:25:34'!
ERROR!

----End fileIn of C:\Users\Maxi\Desktop\Facultad\Inge1\Parciales\2021-1c\2doParcial\ISW1-2021-1C-2doParcial-Resolucion-ConRondaDeTrucoyTurno.st----!
!LaddersAndSlides methodsFor: 'accessing' stamp: 'MY 7/4/2022 20:30:56'!
movePlayer: aPlayer
	
	| xPos yPos newPosition |
	xPos := (dice throwDice) - 6.
	yPos := (dice throwDice) - 6.
	
	newPosition := aPlayer + (xPos@yPos)! !

!classRemoval: #TerminaPie stamp: 'MY 7/4/2022 20:31:41'!
Turno subclass: #TerminaPie
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

!classRemoval: #TerminaMano stamp: 'MY 7/4/2022 20:31:42'!
Turno subclass: #TerminaMano
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

!classRemoval: #RondaFinalizada stamp: 'MY 7/4/2022 20:31:42'!
Turno subclass: #RondaFinalizada
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

!classRemoval: #ComienzaPie stamp: 'MY 7/4/2022 20:31:42'!
Turno subclass: #ComienzaPie
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

!classRemoval: #ComienzaMano stamp: 'MY 7/4/2022 20:31:42'!
Turno subclass: #ComienzaMano
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

!classRemoval: #Turno stamp: 'MY 7/4/2022 20:31:42'!
Object subclass: #Turno
	instanceVariableNames: 'ronda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

!classRemoval: #RondaDeTruco stamp: 'MY 7/4/2022 20:31:43'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'cartasDeManoDisponibles cartasDePieDisponibles puntajeMano puntajePie turno cartasDeManoJugadas cartasDePieJugadas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

!classRemoval: #CartaDeTruco stamp: 'MY 7/4/2022 20:31:43'!
Object subclass: #CartaDeTruco
	instanceVariableNames: 'palo numero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

!classRemoval: #TrucoTest stamp: 'MY 7/4/2022 20:31:43'!
TestCase subclass: #TrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

!classRemoval: #CartaDeTrucoTest stamp: 'MY 7/4/2022 20:31:44'!
TestCase subclass: #CartaDeTrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-ResolucionConTurno'!

----End fileIn of C:\Users\Maxi\Desktop\Facultad\Inge1\Parciales\2021-1c\2doParcial\ISW1-2021-1C-2doParcial-Resolucion-ConRondaDeTrucoYJugador.st----!

!classRemoval: #RondaDeTruco stamp: 'MY 7/4/2022 20:33:44'!
Object subclass: #RondaDeTruco
	instanceVariableNames: 'mano pie'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #JugadorDeTruco stamp: 'MY 7/4/2022 20:33:44'!
Object subclass: #JugadorDeTruco
	instanceVariableNames: 'cartasDisponibles cartasJugadas contrincante ronda'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #CartaDeTruco stamp: 'MY 7/4/2022 20:33:45'!
Object subclass: #CartaDeTruco
	instanceVariableNames: 'palo numero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #TrucoTest stamp: 'MY 7/4/2022 20:33:45'!
TestCase subclass: #TrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!

!classRemoval: #CartaDeTrucoTest stamp: 'MY 7/4/2022 20:33:45'!
TestCase subclass: #CartaDeTrucoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-2doParcial-Resolucion'!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:34:03'!
xtest02MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 andPlayers: 2.
	
	game movePlayer: 1 places: 1@1.
	self assert: (game playerPosition: 1) equals: 2@2.
	game movePlayer: 1 places: 6@6.
	self assert: (game playerPosition: 1) equals: 2@2.
	game movePlayer: 1 places: 12@12.
	self assert: (game playerPosition: 1) equals: 8@8.
	
	! !

!methodRemoval: LaddersAndSlidesTest #test02MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 20:34:03'!
test02MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 andPlayers: 2.
	
	game movePlayer: 1 places: 1@1.
	self assert: (game playerPosition: 1) equals: 2@2.
	game movePlayer: 1 places: 6@6.
	self assert: (game playerPosition: 1) equals: 2@2.
	game movePlayer: 1 places: 12@12.
	self assert: (game playerPosition: 1) equals: 8@8.
	
	!

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 20:34:06'!
PASSED!

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 20:34:06'!
PASSED!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:34:13' prior: 50582423!
test01PlayersMustStartOnBeginning "mínimo 2, no hay máx"

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	
	game players do:[:aPlayer | 
		self assert: [aPlayer position = (1@1)]].! !

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 20:34:15'!
ERROR!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 20:35:20' prior: 50585490!
xtest02MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	
	game movePlayer: 1 places: 1@1.
	self assert: (game playerPosition: 1) equals: 2@2.
	game movePlayer: 1 places: 6@6.
	self assert: (game playerPosition: 1) equals: 2@2.
	game movePlayer: 1 places: 12@12.
	self assert: (game playerPosition: 1) equals: 8@8.
	
	! !

!methodRemoval: LaddersAndSlides class #withFloors:beginningFloor:point:endingFloor:point:andPlayers: stamp: 'MY 7/4/2022 20:35:25'!
withFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint andPlayers: aNumberOfPlayers
	
	^self new initializeWithFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint andPlayers: aNumberOfPlayers.!

!methodRemoval: LaddersAndSlides #initializeWithFloors:beginningFloor:point:endingFloor:point:andPlayers: stamp: 'MY 7/4/2022 20:35:29'!
initializeWithFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint andPlayers: aNumberOfPlayers

	floors := aListOfFloors.
	beginningFloor := aBeginningFloor.
	endingFloor := anEndingFloor.
	begin := beginPoint.
	end := endPoint.
	players := OrderedCollection new.
	aNumberOfPlayers timesRepeat: [ players add: beginPoint ].!

!classDefinition: #Player category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 20:36:06'!
Object subclass: #Player
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 20:36:03' prior: 50582465!
initializeWithFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint withDice: aDice andPlayers: aNumberOfPlayers

	floors := aListOfFloors.
	beginningFloor := aBeginningFloor.
	endingFloor := anEndingFloor.
	begin := beginPoint.
	end := endPoint.
	dice := aDice.
	players := OrderedCollection new.
	aNumberOfPlayers timesRepeat: [ players add: (Player atPosition: beginPoint) ].! !
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 20:36:51' prior: 50585632!
initializeWithFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint withDice: aDice andPlayers: aNumberOfPlayers

	floors := aListOfFloors.
	beginningFloor := aBeginningFloor.
	endingFloor := anEndingFloor.
	begin := beginPoint.
	end := endPoint.
	dice := aDice.
	players := OrderedCollection new.
	self setPlayers: aNumberOfPlayers onPosition: beginPoint.! !
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 20:37:05'!
setPlayers: aNumberOfPlayers onPosition: beginPoint

	^ aNumberOfPlayers timesRepeat: [ players add: (Player atPosition: beginPoint) ]! !
!Player class methodsFor: 'nil' stamp: 'MY 7/4/2022 20:37:42'!
atPosition: aPosition
	
	^self new initializeAtPosition: aPosition.! !

!classDefinition: #Player category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 20:38:22'!
Object subclass: #Player
	instanceVariableNames: 'position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!Player methodsFor: 'nil' stamp: 'MY 7/4/2022 20:38:20'!
atPosition: aPosition

	position := aPosition.! !
!Player methodsFor: 'accessing' stamp: 'MY 7/4/2022 20:38:41'!
position

	^ position.! !

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 20:38:47'!
ERROR!
!Player methodsFor: 'initialize' stamp: 'MY 7/4/2022 20:38:56'!
initializeAtPosition: aPosition 
	self shouldBeImplemented.
	position := aPosition.! !
!Player methodsFor: 'initialize' stamp: 'MY 7/4/2022 20:39:00' prior: 50585695!
initializeAtPosition: aPosition 

	position := aPosition.! !

!methodRemoval: Player #atPosition: stamp: 'MY 7/4/2022 20:39:08'!
atPosition: aPosition

	position := aPosition.!

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 20:39:20'!
PASSED!

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 20:39:20'!
PASSED!

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 20:39:25'!
PASSED!

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 20:39:25'!
PASSED!

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 20:39:28'!
PASSED!

TestCase subclass: #PlayerTest
	instanceVariableNames: 'position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #PlayerTest category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 20:44:37'!
TestCase subclass: #PlayerTest
	instanceVariableNames: 'position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classRemoval: #PlayerTest stamp: 'MY 7/4/2022 20:45:08'!
TestCase subclass: #PlayerTest
	instanceVariableNames: 'position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #LaddersAndSlides category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 20:47:51'!
Object subclass: #LaddersAndSlides
	instanceVariableNames: 'floors beginningFloor endingFloor begin end players dice playerTurn'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 20:47:48' prior: 50585649!
initializeWithFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint withDice: aDice andPlayers: aNumberOfPlayers

	floors := aListOfFloors.
	beginningFloor := aBeginningFloor.
	endingFloor := anEndingFloor.
	begin := beginPoint.
	end := endPoint.
	dice := aDice.
	playerTurn := 1.
	players := OrderedCollection new.
	self setPlayers: aNumberOfPlayers onPosition: beginPoint.! !

10 do: [:num | Player atPosition: (num@(num+1)) ]!

10 iterate: [:num | Player atPosition: (num@(num+1)) ]!

10 timesRepeat: [:num | Player atPosition: (num@(num+1)) ]!

| turn |
turn := 0.
10 timesRepeat: [				Player atPosition: (turn@(turn+1)).
				turn := turn + 1. ]!

| turn players |
turn := 0.
players := OrderedCollection new.
10 timesRepeat: [				players add: (Player atPosition: (turn@(turn+1))).
				turn := turn + 1. ] 
			
players
!

| turn players |
turn := 0.
players := OrderedCollection new.
10 timesRepeat: [				players add: (Player atPosition: (turn@(turn+1))).
				turn := turn + 1. ] 
			!

players!

| turn players |
turn := 0.
players := OrderedCollection new.
10 timesRepeat: [ players add: (Player atPosition: (turn@(turn+1))).
			turn := turn + 1. ] 

players
!

| turn players |
turn := 0.
players := OrderedCollection new.
10 timesRepeat: [ players add: (Player atPosition: (turn@(turn+1))).
			turn := turn + 1. ] !

| turn players |
turn := 0.
players := OrderedCollection new.
10 timesRepeat: [ players add: (Player atPosition: (turn@(turn+1))).
			turn := turn + 1. ] !

players!

| turn players |
turn := 0.
players := OrderedCollection new.
10 timesRepeat: [ players add: (Player atPosition: (turn@(turn+1))).
			turn := turn + 1. ] !
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 20:57:43' prior: 50585665!
setPlayers: aNumberOfPlayers onPosition: beginPoint
	
	| turn |
	
	turn := 1.
	^ aNumberOfPlayers timesRepeat: [ players add: (Player atPosition: beginPoint withTurn: turn).
								turn := turn + 1 ]! !
!Player class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 20:58:04'!
atPosition: aPosition withTurn: aTurn
	
	^self new initializeAtPosition: aPosition withTurn: aTurn.! !

!methodRemoval: Player class #atPosition: stamp: 'MY 7/4/2022 20:58:08'!
atPosition: aPosition
	
	^self new initializeAtPosition: aPosition.!
!Player methodsFor: 'initialize' stamp: 'MY 7/4/2022 20:58:21'!
initializeAtPosition: aPosition withTurn: aTurn

	| turn |
	position := aPosition.
	turn := aTurn.! !
!Player methodsFor: 'initialize' stamp: 'MY 7/4/2022 20:58:40' prior: 50585831!
initializeAtPosition: aPosition withTurn: aTurn

	position := aPosition.
	" := aTurn."! !

!classDefinition: #Player category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 20:58:46'!
Object subclass: #Player
	instanceVariableNames: 'position turn'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!Player methodsFor: 'initialize' stamp: 'MY 7/4/2022 20:58:45' prior: 50585837!
initializeAtPosition: aPosition withTurn: aTurn

	position := aPosition.
	turn := aTurn.! !

!methodRemoval: Player #initializeAtPosition: stamp: 'MY 7/4/2022 20:58:49'!
initializeAtPosition: aPosition 

	position := aPosition.!

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 20:58:54'!
PASSED!

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 20:58:54'!
PASSED!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:01:20'!
xtest03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	
	game movePlayer: 1 places: 1@1.
	self assert: (game playerPosition: 1) equals: 2@2.
	game movePlayer: 1 places: 6@6.
	self assert: (game playerPosition: 1) equals: 2@2.
	game movePlayer: 1 places: 12@12.
	self assert: (game playerPosition: 1) equals: 8@8.
	
	! !

!methodRemoval: LaddersAndSlidesTest #xtest02MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 21:01:20'!
xtest02MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	
	game movePlayer: 1 places: 1@1.
	self assert: (game playerPosition: 1) equals: 2@2.
	game movePlayer: 1 places: 6@6.
	self assert: (game playerPosition: 1) equals: 2@2.
	game movePlayer: 1 places: 12@12.
	self assert: (game playerPosition: 1) equals: 8@8.
	
	!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:01:30' prior: 50585546!
test01PlayersMustStartOnBeginning

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	
	game players do:[:aPlayer | 
		self assert: [aPlayer position = (1@1)]].! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:02:09'!
test02PlayerCanOnlyMoveInItsTurn

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1.
	
	game players do:[:aPlayer | 
		self assert: [aPlayer position = (1@1)]].! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:03:20' prior: 50585938!
test02PlayerCanOnlyMoveInItsTurn

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1.
	
	self  should: [ game movePlayer: 1 ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | anError messageText = LaddersAndSlides playerCannotMoveInOthersTurn ]! !

!testRun: #LaddersAndSlidesTest #test02PlayerCanOnlyMoveInItsTurn stamp: 'MY 7/4/2022 21:03:29'!
FAILURE!
!LaddersAndSlides methodsFor: 'accessing' stamp: 'MY 7/4/2022 21:06:11' prior: 50583960!
movePlayer: aPlayer
	
	| player |
	player := players at: aPlayer.
	player throwDice.
! !
!Player methodsFor: 'accessing' stamp: 'MY 7/4/2022 21:06:33'!
throwDice: aDice

	^ aDice throwDice.! !
!LaddersAndSlides methodsFor: 'accessing' stamp: 'MY 7/4/2022 21:07:38' prior: 50585984!
movePlayer: aPlayer
	
	| player |
	player := players at: aPlayer.
	player throwDice: dice.
	
	playerTurn := playerTurn + 1.! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:08:33'!
xtest03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSixAndIncrement

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 1@1.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 6@6.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 12@12.
	self assert: (game playerPosition: 1) equals: 8@8.
	
	! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:08:44' prior: 50585867!
xtest03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 1@1.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 6@6.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 12@12.
	self assert: (game playerPosition: 1) equals: 8@8.
	
	! !

!methodRemoval: LaddersAndSlidesTest #xtest03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSixAndIncrement stamp: 'MY 7/4/2022 21:08:47'!
xtest03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSixAndIncrement

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 1@1.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 6@6.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 12@12.
	self assert: (game playerPosition: 1) equals: 8@8.
	
	!
!LaddersAndSlides methodsFor: 'accessing' stamp: 'MY 7/4/2022 21:09:45' prior: 50585994!
movePlayer: aPlayer
	
	| player |
	player := players at: aPlayer.
	
	"player throwDice: dice.
	
	playerTurn := playerTurn + 1."! !
!LaddersAndSlides methodsFor: 'accessing' stamp: 'MY 7/4/2022 21:10:24' prior: 50586105!
movePlayer: aPlayer
	
	| player |
	(playerTurn ~= aPlayer) ifTrue: [self error: LaddersAndSlides ].
	player := players at: aPlayer.
	playerTurn := playerTurn + 1.
	
	"player throwDice: dice.
	
	playerTurn := playerTurn + 1."! !
!LaddersAndSlides methodsFor: 'accessing' stamp: 'MY 7/4/2022 21:10:36' prior: 50586112!
movePlayer: aPlayer
	
	| player |
	(playerTurn ~= aPlayer) ifTrue: [self error: LaddersAndSlides playerCannotMoveInOthersTurn].
	player := players at: aPlayer.
	playerTurn := playerTurn + 1.
	
	"player throwDice: dice.
	
	playerTurn := playerTurn + 1."! !
!LaddersAndSlides class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 21:10:58'!
playerCannotMoveInOthersTurn

	^'No es el turno de este jugador'! !

!testRun: #LaddersAndSlidesTest #test02PlayerCanOnlyMoveInItsTurn stamp: 'MY 7/4/2022 21:11:04'!
PASSED!

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 21:11:04'!
PASSED!

!testRun: #LaddersAndSlidesTest #test02PlayerCanOnlyMoveInItsTurn stamp: 'MY 7/4/2022 21:11:04'!
PASSED!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:11:14'!
test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 1@1.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 6@6.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 12@12.
	self assert: (game playerPosition: 1) equals: 8@8.
	
	! !

!methodRemoval: LaddersAndSlidesTest #xtest03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 21:11:14'!
xtest03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 1@1.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 6@6.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 12@12.
	self assert: (game playerPosition: 1) equals: 8@8.
	
	!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:11:24'!
xtest03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 1@1.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 6@6.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 12@12.
	self assert: (game playerPosition: 1) equals: 8@8.
	
	! !

!methodRemoval: LaddersAndSlidesTest #test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 21:11:24'!
test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 1@1.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 6@6.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 12@12.
	self assert: (game playerPosition: 1) equals: 8@8.
	
	!

10 mod: 10!

10 mod: 9!

9 mod: 9!

9 % 9!

9 % 10!

((playerTurn mod: (players size) + 1)  = 2)!

|playerTurn players |
playerTurn := 10.
players := OrderedCollection new.
((playerTurn mod: (players size) + 1)  = 2)!

|playerTurn players |
playerTurn := 10.
players := OrderedCollection ofSize: 10 .
((playerTurn mod: (players size) + 1)  = 2)  !

((playerTurn mod: (players size) + 1)  = 10) !

|playerTurn players |
playerTurn := 10.
players := OrderedCollection ofSize: 10 .
((playerTurn mod: (players size) + 1)  = 10) !

|playerTurn players |
playerTurn := 20.
players := OrderedCollection ofSize: 10 .
((playerTurn mod: (players size) + 1)  = 10) !

|playerTurn players |
playerTurn := 1.
players := OrderedCollection ofSize: 10 .
((playerTurn mod: (players size) + 1)  = 1)!

|playerTurn players |
playerTurn := 2.
players := OrderedCollection ofSize: 10 .
((playerTurn mod: (players size) + 1)  = 2)!

|playerTurn players |
playerTurn := 10.
players := OrderedCollection ofSize: 10 .
((playerTurn mod: (players size) + 1)  = 10)!

|playerTurn players |
playerTurn := 11.
players := OrderedCollection ofSize: 10 .
((playerTurn mod: (players size) + 1)  = 11)!

|playerTurn players |
playerTurn := 11.
players := OrderedCollection ofSize: 10 .
((playerTurn mod: ((players size) + 1))  = 11)  !

|playerTurn players |
playerTurn := 11.
players := OrderedCollection ofSize: 10 .
((playerTurn mod: (players size) + 1)  = 1)  !

|playerTurn players |
playerTurn := 11.
players := OrderedCollection ofSize: 10 .
((playerTurn mod: ((players size) + 1))  = 1)  !

|playerTurn players |
playerTurn := 11.
players := OrderedCollection ofSize: 10 .
players size!

|playerTurn players |
playerTurn := 11.
players := OrderedCollection ofSize: 10 .
((playerTurn mod: (players size)) + 1  = 1)  !

|playerTurn players |
playerTurn := 11.
players := OrderedCollection ofSize: 10 .
(((playerTurn mod: (players size)) + 1)  = 1)  !

10 mod: 10!

10 mod: 11 !

|playerTurn players |
playerTurn := 10.
players := OrderedCollection ofSize: 10 .
((playerTurn mod: (players size))  = 10 mod: 10)  

!

|playerTurn players |
playerTurn := 10.
players := OrderedCollection ofSize: 10 .
((playerTurn mod: (players size)) = (10 mod: 10))  

!

|playerTurn players |
playerTurn := 11.
players := OrderedCollection ofSize: 10 .
((playerTurn mod: (players size)) = (11 mod: 10))  !
!LaddersAndSlides methodsFor: 'accessing' stamp: 'MY 7/4/2022 21:18:43' prior: 50586122!
movePlayer: aPlayer
	
	| player |
	((playerTurn mod: (players size)) ~= (aPlayer mod: (players size))) ifTrue: [self error: LaddersAndSlides playerCannotMoveInOthersTurn].
	player := players at: aPlayer.
	playerTurn := playerTurn + 1.
	
	"player throwDice: dice.
	
	playerTurn := playerTurn + 1."! !

!testRun: #LaddersAndSlidesTest #test02PlayerCanOnlyMoveInItsTurn stamp: 'MY 7/4/2022 21:18:49'!
PASSED!

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 21:18:49'!
PASSED!

!testRun: #LaddersAndSlidesTest #test02PlayerCanOnlyMoveInItsTurn stamp: 'MY 7/4/2022 21:18:49'!
PASSED!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:19:27' prior: 50585958!
test02PlayerCanOnlyMoveInItsTurn

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1.
	
	self  should: [ game movePlayer: 1 ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | anError messageText = LaddersAndSlides playerCannotMoveInOthersTurn ].

	game movePlayer: 2.
	self  should: [ game movePlayer: 2 ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | anError messageText = LaddersAndSlides playerCannotMoveInOthersTurn ].! !

!testRun: #LaddersAndSlidesTest #test02PlayerCanOnlyMoveInItsTurn stamp: 'MY 7/4/2022 21:19:28'!
PASSED!

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 21:19:28'!
PASSED!

!testRun: #LaddersAndSlidesTest #test02PlayerCanOnlyMoveInItsTurn stamp: 'MY 7/4/2022 21:19:29'!
PASSED!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:19:41' prior: 50586381!
test02PlayerCanOnlyMoveInItsTurn

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 1@1 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1.
	
	self  should: [ game movePlayer: 1 ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | anError messageText = LaddersAndSlides playerCannotMoveInOthersTurn ].
	game movePlayer: 2.
	
	self  should: [ game movePlayer: 2 ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | anError messageText = LaddersAndSlides playerCannotMoveInOthersTurn ].! !

!testRun: #LaddersAndSlidesTest #test02PlayerCanOnlyMoveInItsTurn stamp: 'MY 7/4/2022 21:19:43'!
PASSED!

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 21:19:43'!
PASSED!

!testRun: #LaddersAndSlidesTest #test02PlayerCanOnlyMoveInItsTurn stamp: 'MY 7/4/2022 21:19:43'!
PASSED!
!LaddersAndSlides methodsFor: 'accessing' stamp: 'MY 7/4/2022 21:20:06'!
validateIsPlayerTurn: aPlayer

	^ ((playerTurn mod: (players size)) ~= (aPlayer mod: (players size))) ifTrue: [self error: LaddersAndSlides playerCannotMoveInOthersTurn]! !
!LaddersAndSlides methodsFor: 'accessing' stamp: 'MY 7/4/2022 21:20:06' prior: 50586358!
movePlayer: aPlayer
	
	| player |
	self validateIsPlayerTurn: aPlayer.
	player := players at: aPlayer.
	playerTurn := playerTurn + 1.
	
	"player throwDice: dice.
	
	playerTurn := playerTurn + 1."! !

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 21:20:09'!
PASSED!

!testRun: #LaddersAndSlidesTest #test02PlayerCanOnlyMoveInItsTurn stamp: 'MY 7/4/2022 21:20:09'!
PASSED!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:20:21'!
test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 1@1.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 6@6.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 12@12.
	self assert: (game playerPosition: 1) equals: 8@8.
	
	! !

!methodRemoval: LaddersAndSlidesTest #xtest03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 21:20:21'!
xtest03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 1@1.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 6@6.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 12@12.
	self assert: (game playerPosition: 1) equals: 8@8.
	
	!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:25:58' prior: 50586483!
test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 1@1.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 6@6.
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: 1 places: 12@12.
	self assert: (game playerPosition: 1) equals: 8@8.
	
	! !
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:26:33' prior: 50586467!
movePlayer: aPlayer
	
	| player |
	self validateIsPlayerTurn: aPlayer.
	player := players at: aPlayer.
	player move.
	playerTurn := playerTurn + 1.
	
	"player throwDice: dice.
	
	playerTurn := playerTurn + 1."! !
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:33:45' prior: 50586586!
movePlayer: aPlayer
	
	| player xPos yPos |
	self validateIsPlayerTurn: aPlayer.
	player := players at: aPlayer.
	xPos := player throwDice: dice.
	yPos := player throwDice: dice.
	self move: player positions: (xPos@yPos).
	
	playerTurn := playerTurn + 1.
	
	"player throwDice: dice.
	
	playerTurn := playerTurn + 1."! !
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:34:03' prior: 50586596!
movePlayer: aPlayer
	
	| player xPos yPos |
	self validateIsPlayerTurn: aPlayer.
	player := players at: aPlayer.
	xPos := player throwDice: dice.
	yPos := player throwDice: dice.
	self move: player places: (xPos@yPos).
	
	playerTurn := playerTurn + 1.
	
	"player throwDice: dice.
	
	playerTurn := playerTurn + 1."! !
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:34:15' prior: 50586609!
movePlayer: aPlayer
	
	| player xPos yPos |
	
	self validateIsPlayerTurn: aPlayer.
	player := players at: aPlayer.
	xPos := player throwDice: dice.
	yPos := player throwDice: dice.
	self move: player places: (xPos@yPos).
	
	playerTurn := playerTurn + 1.! !
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:34:51'!
move: aPlayer places: aPoint
	
	| player xPos yPos |
	
	self validateIsPlayerTurn: aPlayer.
	player := players at: aPlayer.
	xPos := player throwDice: dice.
	yPos := player throwDice: dice.
	player setPosition: (xPos@yPos).
	
	playerTurn := playerTurn + 1.! !
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:35:01' prior: 50586622!
movePlayer: aPlayer
	
	| player xPos yPos |
	
	self validateIsPlayerTurn: aPlayer.
	player := players at: aPlayer.
	xPos := player throwDice: dice.
	yPos := player throwDice: dice.
	player setPosition: (xPos@yPos).
	
	playerTurn := playerTurn + 1.! !

!methodRemoval: LaddersAndSlides #move:places: stamp: 'MY 7/4/2022 21:35:04'!
move: aPlayer places: aPoint
	
	| player xPos yPos |
	
	self validateIsPlayerTurn: aPlayer.
	player := players at: aPlayer.
	xPos := player throwDice: dice.
	yPos := player throwDice: dice.
	player setPosition: (xPos@yPos).
	
	playerTurn := playerTurn + 1.!
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:37:32' prior: 50586644!
movePlayer: aPlayer
	
	| player |
	
	self validateIsPlayerTurn: aPlayer.
	player := players at: aPlayer.
	player move.
	players at: aPlayer put: player.
	playerTurn := playerTurn + 1.! !
!Player methodsFor: 'playing' stamp: 'MY 7/4/2022 21:38:39'!
moveWithDice: aDice

	| xPos yPos |
	xPos := self throwDice: aDice.
	yPos := self throwDice: aDice.
	self setPosition: (xPos@yPos).
	! !
!Player methodsFor: 'accessing' stamp: 'MY 7/4/2022 21:38:54'!
setPosition: aPosition

	position := aPosition.! !
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:39:18' prior: 50586666!
movePlayer: aPlayer
	
	| player |
	
	self validateIsPlayerTurn: aPlayer.
	player := players at: aPlayer.
	player moveWithDice: dice.
	players at: aPlayer put: player.
	playerTurn := playerTurn + 1.! !
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:40:12' prior: 50586686!
movePlayer: aPlayer
	
	| player |
	
	self validateIsPlayerTurn: aPlayer.
	player := players at: aPlayer.
	player moveWithDice: dice on: self.
	players at: aPlayer put: player.
	playerTurn := playerTurn + 1.! !
!Player methodsFor: 'playing' stamp: 'MY 7/4/2022 21:40:48'!
moveWithDice: aDice on: aGame

	| xPos yPos |
	xPos := self throwDice: aDice.
	yPos := self throwDice: aDice.
	aGame movePlayer: self to: (xPos@yPos).
	! !
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:42:05'!
movePlayer: aPlayer to: aPoint
	
	
	
	^ aPlayer setPosition: (aPoint + (-6@-6)).! !
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:42:11' prior: 50586712!
movePlayer: aPlayer to: aPoint

	
	^ aPlayer setPosition: (aPoint + (-6@-6)).! !
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:42:12' prior: 50586718!
movePlayer: aPlayer to: aPoint
	
	^ aPlayer setPosition: (aPoint + (-6@-6)).! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:44:07' prior: 50586552!
test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: ((game players) at: 1) to: (1@1).
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: ((game players) at: 1) to: (6@6).
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: ((game players) at: 1) to: (12@12).
	self assert: (game playerPosition: 1) equals: 8@8.
	
	! !
!LaddersAndSlides methodsFor: 'accessing' stamp: 'MY 7/4/2022 21:44:29'!
playerPosition: aPlayer

	^ (players at: aPlayer) position! !

!testRun: #LaddersAndSlidesTest #test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 21:44:34'!
ERROR!
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:44:46' prior: 50586724!
movePlayer: aPlayer to: aPoint
	
	^ aPlayer setPosition: (aPoint - (6@6)).! !

!testRun: #LaddersAndSlidesTest #test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 21:44:50'!
FAILURE!
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:47:04' prior: 50586775!
movePlayer: aPlayer to: aPoint
	
	^ aPlayer setPosition: (aPlayer position) + (aPoint - (6@6)).! !

!testRun: #LaddersAndSlidesTest #test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 21:47:05'!
FAILURE!

!testRun: #LaddersAndSlidesTest #test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 21:47:09'!
FAILURE!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:48:47' prior: 50586730!
test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix

	| firstFloor secondFloor game floors dice |
	
	firstFloor := self firstFloor.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: ((game players) at: 1) to: (1@1).
	self assert: (game playerPosition: 1) equals: 2@2.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: ((game players) at: 1) to: (6@6).
	self assert: (game playerPosition: 1) equals: 7@7.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 7@7 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: ((game players) at: 1) to: (12@12).
	self assert: (game playerPosition: 1) equals: 13@13.
	
	! !

!testRun: #LaddersAndSlidesTest #test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 21:48:47'!
PASSED!

!testRun: #LaddersAndSlidesTest #test01PlayersMustStartOnBeginning stamp: 'MY 7/4/2022 21:48:47'!
PASSED!

!testRun: #LaddersAndSlidesTest #test02PlayerCanOnlyMoveInItsTurn stamp: 'MY 7/4/2022 21:48:47'!
PASSED!

!testRun: #LaddersAndSlidesTest #test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 21:48:47'!
PASSED!
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:50:21' prior: 50581662!
xtest04IfPlayerMovedMoreThanMapBorderItShouldLandAtBorder

	
	| firstFloor secondFloor game floors dice |
	
	firstFloor := self floorWithoutShortcutsLevel: 1.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 2@2 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: ((game players) at: 1) to: (1@1).
	self assert: (game playerPosition: 1) equals: 1@1.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 2@2 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: ((game players) at: 1) to: (12@12).
	self assert: (game playerPosition: 1) equals: 1@1.! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:50:30' prior: 50586853!
xtest04IfPlayerMovedMoreThanMapBorderItShouldLandAtBorder

	
	| firstFloor secondFloor game floors dice |
	
	firstFloor := self floorWithoutShortcutsLevel: 1.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 2@2 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: ((game players) at: 1) to: (1@1).
	self assert: (game playerPosition: 1) equals: 4@5.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 2@2 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: ((game players) at: 1) to: (12@12).
	self assert: (game playerPosition: 1) equals: 1@1.! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:50:56' prior: 50586882!
xtest04IfPlayerMovedMoreThanMapBorderItShouldLandAtBorder

	
	| firstFloor secondFloor game floors dice |
	
	firstFloor := self floorWithoutShortcutsLevel: 1.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 2@2 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: ((game players) at: 1) to: (1@1).
	self assert: (game playerPosition: 1) equals: 1@1.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 2@2 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: ((game players) at: 1) to: (12@12).
	self assert: (game playerPosition: 1) equals: 4@5.! !
!LaddersAndSlidesTest methodsFor: 'as yet unclassified' stamp: 'MY 7/4/2022 21:51:01'!
test04IfPlayerMovedMoreThanMapBorderItShouldLandAtBorder

	
	| firstFloor secondFloor game floors dice |
	
	firstFloor := self floorWithoutShortcutsLevel: 1.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 2@2 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: ((game players) at: 1) to: (1@1).
	self assert: (game playerPosition: 1) equals: 1@1.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 2@2 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: ((game players) at: 1) to: (12@12).
	self assert: (game playerPosition: 1) equals: 4@5.! !

!methodRemoval: LaddersAndSlidesTest #xtest04IfPlayerMovedMoreThanMapBorderItShouldLandAtBorder stamp: 'MY 7/4/2022 21:51:01'!
xtest04IfPlayerMovedMoreThanMapBorderItShouldLandAtBorder

	
	| firstFloor secondFloor game floors dice |
	
	firstFloor := self floorWithoutShortcutsLevel: 1.
	secondFloor := self floorWithoutShortcutsLevel: 2.
	floors := OrderedCollection newFrom: (Array with: firstFloor with: secondFloor).
	dice := Dice withFaces: 12.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 2@2 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: ((game players) at: 1) to: (1@1).
	self assert: (game playerPosition: 1) equals: 1@1.
	
	game := LaddersAndSlides withFloors: floors beginningFloor: 1 point: 2@2 endingFloor: 2 point: 4@4 withDice: dice andPlayers: 2.
	game movePlayer: ((game players) at: 1) to: (12@12).
	self assert: (game playerPosition: 1) equals: 4@5.!

!testRun: #LaddersAndSlidesTest #test04IfPlayerMovedMoreThanMapBorderItShouldLandAtBorder stamp: 'MY 7/4/2022 21:51:02'!
FAILURE!
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:52:34' prior: 50586785!
movePlayer: aPlayer to: aPoint
	
	| newPosition |
	newPosition := 1.
	((aPlayer position) + (aPoint - (6@6))).

	^ aPlayer setPosition: 1@1.! !

Object subclass: #Player
	instanceVariableNames: 'position turn level'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!

!classDefinition: #Player category: 'ISW1-2022-1C-2doParcial' stamp: 'MY 7/4/2022 21:53:00'!
Object subclass: #Player
	instanceVariableNames: 'position turn level'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-2doParcial'!
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 21:53:43' prior: 50585755!
initializeWithFloors: aListOfFloors beginningFloor: aBeginningFloor point: beginPoint endingFloor: anEndingFloor point: endPoint withDice: aDice andPlayers: aNumberOfPlayers

	floors := aListOfFloors.
	beginningFloor := aBeginningFloor.
	endingFloor := anEndingFloor.
	begin := beginPoint.
	end := endPoint.
	dice := aDice.
	playerTurn := 1.
	players := OrderedCollection new.
	self setPlayers: aNumberOfPlayers onPosition: beginPoint andLevel: aBeginningFloor .! !
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 21:53:54'!
setPlayers: aNumberOfPlayers onPosition: beginPoint andLevel: aBeginningFloor
	
	| turn |
	
	turn := 1.
	^ aNumberOfPlayers timesRepeat: [ players add: (Player atPosition: beginPoint withTurn: turn).
								turn := turn + 1 ]! !
!LaddersAndSlides methodsFor: 'initialize' stamp: 'MY 7/4/2022 21:53:58' prior: 50587037!
setPlayers: aNumberOfPlayers onPosition: beginPoint andLevel: aBeginningFloor
	
	| turn |
	
	turn := 1.
	^ aNumberOfPlayers timesRepeat: [ players add: (Player atPosition: beginPoint withTurn: turn andLevel: aBeginningFloor).
								turn := turn + 1 ]! !

!methodRemoval: LaddersAndSlides #setPlayers:onPosition: stamp: 'MY 7/4/2022 21:54:02'!
setPlayers: aNumberOfPlayers onPosition: beginPoint
	
	| turn |
	
	turn := 1.
	^ aNumberOfPlayers timesRepeat: [ players add: (Player atPosition: beginPoint withTurn: turn).
								turn := turn + 1 ]!
!Player methodsFor: 'initialize' stamp: 'MY 7/4/2022 21:54:08'!
initializeAtPosition: aPosition withTurn: aTurn andLevel: aBeginningFloor

	position := aPosition.
	turn := aTurn.! !
!Player methodsFor: 'initialize' stamp: 'MY 7/4/2022 21:54:14' prior: 50587067!
initializeAtPosition: aPosition withTurn: aTurn andLevel: aBeginningFloor

	position := aPosition.
	turn := aTurn.
	level := aBeginningFloor.! !
!Player class methodsFor: 'instance creation' stamp: 'MY 7/4/2022 21:54:20'!
atPosition: aPosition withTurn: aTurn andLevel: aBeginningFloor
	
	^self new initializeAtPosition: aPosition withTurn: aTurn andLevel: aBeginningFloor.! !

!methodRemoval: Player class #atPosition:withTurn: stamp: 'MY 7/4/2022 21:54:22'!
atPosition: aPosition withTurn: aTurn
	
	^self new initializeAtPosition: aPosition withTurn: aTurn.!
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:54:57' prior: 50587000!
movePlayer: aPlayer to: aPoint
	
	| newPosition |
	newPosition := 1.
	((aPlayer position) + (aPoint - (6@6))). 
	floors at: (aPlayer level).

	^ aPlayer setPosition: 1@1.! !
!Player methodsFor: 'accessing' stamp: 'MY 7/4/2022 21:55:08'!
level

	^ level.! !
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:58:20' prior: 50587095!
movePlayer: aPlayer to: aPoint
	
	| newPosition floorMap limitMap |
	floorMap := floors at: (aPlayer level) map.
	newPosition := (aPlayer position) + (aPoint - (6@6)).
	limitMap := (floorMap width)@(floorMap width).
	(newPosition > limitMap) ifTrue: [newPosition := limitMap] .
	(newPosition < 1@1) ifTrue: [newPosition := 1@1].

	^ aPlayer setPosition: newPosition.! !

!testRun: #LaddersAndSlidesTest #test04IfPlayerMovedMoreThanMapBorderItShouldLandAtBorder stamp: 'MY 7/4/2022 21:58:24'!
ERROR!

!testRun: #LaddersAndSlidesTest #test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 21:58:29'!
ERROR!

!testRun: #LaddersAndSlidesTest #test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 21:58:29'!
ERROR!
!LaddersAndSlides methodsFor: 'playing' stamp: 'MY 7/4/2022 21:58:41' prior: 50587107!
movePlayer: aPlayer to: aPoint
	
	| newPosition floorMap limitMap |
	floorMap := (floors at: (aPlayer level)) map.
	newPosition := (aPlayer position) + (aPoint - (6@6)).
	limitMap := (floorMap width)@(floorMap width).
	(newPosition > limitMap) ifTrue: [newPosition := limitMap] .
	(newPosition < 1@1) ifTrue: [newPosition := 1@1].

	^ aPlayer setPosition: newPosition.! !

!testRun: #LaddersAndSlidesTest #test03MovePlayerShouldTranslatePlayerBetweenNegativeFiveAndPositiveSix stamp: 'MY 7/4/2022 21:58:47'!
ERROR!

----SNAPSHOT----(4 July 2022 21:58:53) CuisUniversity-5324.image priorSource: 7667134!